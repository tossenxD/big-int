\section{Division}
\label{sec:div}

The last of the basic arithmetics is division. It is far more complicated than
the others and intrinsically in conflict with our domain. We say that the
division is \textit{exact} when the divisor precisely divides the dividend. When
the division is not exact, the result is ordinarily represented by a fraction --
yet we do not desire to leave the domain of integers. Instead, we use the notion
of \textit{quotient} and \textit{remainder} commonly present in integer
semantics:
\begin{align}
  u~\mathtt{quo}~v &\coloneq \lfloor u/v \rfloor\\
  u~ \mathtt{rem}~v &\coloneq u - \left( u~\mathtt{quo}~v \right)\cdot v
\end{align}
Usually, the quotient is associated with the division operator, and the
remainder with the modulus operator. Our division computes both values and
returns them as a pair.

A common way to reason about division is to multiply the dividend with the
inverse of the divisor, also called the reciprocal. GMP use reciprocals for
division by single precision, but since reciprocals are expensive to compute,
their base case division use Knuth's algorithm for long division, also known as
\textit{grade-school} division \cite{GMP, knuth97}. This algorithm is inherently
sequential: It iteratively produce the result by finding one correct digit per
iteration, and thus, unfit for GPGPU. As a result, we focus on algorithms using
the inverse of the divisor.

A well known algorithm to find reciprocals is the Newton-Raphson method. It
takes an initial approximation, and through a series of iterative steps (also
called Newton iterations), refines the precision of the approximation. While it
runs a number of inherently sequential iterations too, the precision of the
approximation roughly doubles at each iteration, making it more suitable for
GPGPU than long division.

However, it presents a new hurdle w.r.t.\ the internal representation of both
the inverse and the intermediate approximations in iteration steps. One solution
is to use fractions internally and convert back to integers before returning the
output. The downsides to this solution is the potential loss of precision when
using floating points (i.e.\ it will no longer be an exact arithmetic) and the
overhead of converting between representations.

Instead, we use Watt's efficient and exact arithmetic algorithm for computing
quotients, presented in \cite{watt2023efficient}. The prerequisite of the
algorithm is the existence of a shift operation for the chosen data type -- which
is na efficient operation for integers -- and a multiplication method given as an
argument. The intuition is to utilize the shift operation in order to avoid the
domain change associated with computing the inverse, by instead computing what
is referred to as the \textit{whole shifted inverse}.

This section is structured as follows: In \ref{subsec:divalg} we give a detailed
introduction to the algorithm formulated by Watt in \cite{watt2023efficient}. We
also present a revision to the algorithm regarding an unconsidered corner case,
and specialize it to the domain of big integers. In \ref{subsec:divproto} we
further discuss its adaptability w.r.t.\ big integers, and raise concerns and
solutions based on a sequential prototype of the algorithm written in C. It
serves to fully understand the complexities involved in adapting the algorithm
to big integers. Lastly, in \ref{subsec:divfut} we give an overview on how to
parallelize the algorithm based on Futhark.

\subsection{Algorithm}
\label{subsec:divalg}

Before discussing the exact division algorithm, we introduce a new notation: The
\textit{precision} of a big integer (denoted by $p$) refers to the number of
digits without leading zeroes. E.g.\ the integer $\arr{1,2,0}$ has size $m=3$
and precision $p=2$.

We will now give the intuition behind the algorithm defined by Watt in
\cite{watt2023efficient}, and refer to the original paper for proofs and a
generic version. The foundation of the algorithm is a whole shift operator and a
whole shifted inverse operator:

\begin{definition}[whole shift and whole shifted inverse of big integers]\label{def:shifts}
  We define a $n \in \mathbb{Z}$ whole shift and $n' \in \mathbb{N}$ whole shifted inverse of big
  integers $u\in \mathbb{N}$ and $v\in \mathbb{N}^{+}$ in base $B$ as:
  \begin{equation}\label{eq:shifts}
    \mathtt{shift}_n~u \coloneq \lfloor u \cdot B^n \rfloor \quad \qquad \mathtt{shinv}_{n'}~v \coloneq \lfloor B^{n'}/ v \rfloor
    \end{equation}
\end{definition}

A shift in our array-oriented representation behaves similarly to a binary
system arithmetic shift, e.g.\ $\mathtt{shift}_1~\arr{1,2,3} = \arr{0,1,2}$ and
$\mathtt{shift}_{-1}~\arr{1,2,3} = \arr{2,3,0}$. The shifted inverse has a more
abstract interpretation -- given some $n'>p$ it essentially behaves as a
fractional inverse that is then "shifted into our domain". Consider the
following example:

\begin{example}[interpretation of the whole shifted inverse]
Suppose we have the integer $u=\arr{1,2,3}$ in base $B=2^{32}$ and wish to divide
it by the integer $v=\arr{1,1,0}$ in base $B$. Since $v$ is of precision $p=2$,
we get a proper inverse representation of $v$ by computing the $n$ shifted
inverse for some $n>p$. We pick $n=3$:
\begin{equation}
\label{eq:3}
\mathtt{shinv}_3~\arr{1,1,0} = \arr{0,4294967295,0}
\end{equation}
We can then multiply $u$ with the shifted inverse (expanding the result size),
and get:
\begin{equation}
  \label{eq:4}
  \arr{1,2,3}\cdot\arr{0,4294967295,0} = \arr{0,4294967295,4294967294,4294967294,2}
\end{equation}
Now, since the fractional part of the inverse was "shifted into our domain" by
3, the result of this multiplication is also shifted by 3 (from associativity of
multiplication). Hence we shift it by $-3$ (and compress it to the original
size):
\begin{equation}
  \label{eq:5}
  \mathtt{shift}_{-3}~\arr{0,4294967295,4294967294,4294967294,2} = \arr{4294967294,2,0}
\end{equation}
The correct answer is $\arr{4294967295,2,0}$, so the method is off by one. This
is an accommodated byproduct of computing the whole shifted inverse. However,
the method approximates the result by a difference of one at most, allowing us
to mechanically adjust the result.\newline
\end{example}

The formal definition given by Watt in Theorem 1 of his paper
\cite{watt2023efficient} is as follows:

\begin{definition}[quotient of big integers by whole shifted inverse]\label{def:quo}
  For the base $B$ big integers $u$ and $v$ and some $h\in \mathbb{N}$ s.t.\
  $u \leq B^h$, the quotient of $u$ by $v$ is:
  \begin{equation}
    \label{eq:defquo}
    u~\mathtt{quo}~v = \mathtt{shift}_{-h}~ (u \cdot \mathtt{shinv}_h~v) + \delta,\quad \text{where~} \delta \in \{0,1\}
  \end{equation}
\end{definition}

The challenge now lies in computing \texttt{shinv}. Watt's algorithm use a
Newton iteration over integers and specialized to the base, in order to use
shifts rather than fractions. The algorithm can roughly be divided into three
steps:
\begin{enumerate}[label=\Roman*]
\item Handle the special (and easy) cases, namely when $v \leq B$ or $v > B^h/2$.\label{shinvI}
\item Find an initial approximation that guarantees the Newton iterations
  converges fast.\label{shinvII}
\item Refine the initial approximation iteratively until it is sufficient.\label{shinvIII}
\end{enumerate}
Listing \ref{shinv} below shows the pseudocode for this operation. In step
\ref{shinvI} we have four special cases. They serve dual purposes: To guarantee
that $B < v \leq B^h/2$ (an assumption of the initial approximation for fast
convergence) and to be faster. The first case is when $v$ only consists of a
single digit, and we use a division by single precision method.\footnote{As
  mentioned earlier in how GMP handle division, this case can generally be
  handled more efficient.} The next two cases is if $v > u$ or $2v > u$ and so
the inverse is $0$ and $1$, respectively. The last case is when $v$ is an exact
power of its base, and we can use the rule $x^a/x^b=x^{a-b}$ instead.

Step \ref{shinvII} computes the initial approximation using the last three
digits of $v$, e.g.\ for $v$ of size $m$ we get $V= \arr{v[m-3],v[m-2],v[m-1]}$.
However, this is where we introduce our revision: Computing $V$ in this manner
requires $v \geq B^2$, which is not guaranteed by the special cases. This function
instead assumes that the precision of $v$ is not 2, i.e.
$B^k\leq v < B^{k+1} \land k \neq 1$. We show how to enforce this assumption when
presenting Listing \ref{div}, and shortly see why the assumption is important.

Hence, the initial approximation of $w$ (line 9) always consists of two leading
correct digits. Step \ref{shinvIII} checks whether the shifted inverse consists
of one or two digits, and return the approximation accordingly. If it needs more
digits of precision, it starts the refinement process using the specialized
Newton iteration. Watt presents three refinement methods with a varying degree
of optimizations. The method we use is the optimal (\texttt{refine3} of
Algorithm 1 in \cite{watt2023efficient}), which we describe shortly when
presenting Listing \ref{refine}. However, it use \textit{shorter iterates},
which has the side effect of each iteration being one digit short from doubling
the precision. This means that the number of correct leading digits, from now on
referred to as $l$, must be $\geq 2$. Thus, if $k = 1$ and we are in the case where
$h-k>2$, then we would start refining on $l=1$. In turn, one digit short of
doubling $l=1$ is $l=1$, and hence, the refinement process never increases the
precision and runs forever.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing \texttt{shinv}$_h~v$ in base $B$, where $B^k \leq v < B^{k+1}, k\neq 1$, \texttt{quo}$_{\mathtt{digit}}$ and \texttt{*}$_{\mathtt{digit}}$ are quotient and multiplication by single precision, and \texttt{REFINE} is an approximation refinement method.},label={shinv}]
fun SHINV h k v =
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvI}}! Special cases
  if v          <  B!$^{\phantom{\texttt{h}}}$! then return B!$^\mathtt{h}$! quo!$_{\texttt{digit}}$! v[0]
  if v          >  B!$^\texttt{h}$! then return 0
  if (v *!$_{\texttt{digit}}$! 2) >  B!$^\texttt{h}$! then return 1
  if v          == B!$^\mathtt{k}$! then return B!$^{\texttt{h}-\texttt{k}}$!
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvII}}! Initial approximation
  V = v[k-2] + (v[k-1] * B) + (v[k] * B!$^{\texttt{2}}$!)
  w = (B!$^{\texttt{4}}$! - V) / V + 1
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvIII}}! Refine until sufficient
  if h - k <= 2 then return shift (h - k - 2) w 
  return REFINE v w h k 2
\end{lstlisting}

We will now present how to compute Definition \ref{def:quo} using \texttt{SHINV}
and how to enforce the assumption $k\neq 1$ using shifts. The Pseudocode is in
Listing \ref{div} and contains four steps:
\begin{enumerate}
\item Lines 3-4 computes the assumptions straightforward using helpers from
  Figure \ref{divhelpers}.
\item Lines 6-9 handles the case $k=1$ by shifting both $u$ and $v$ by
  one. Note, a shift is equivalent to a multiplication by definition, so the
  quotient is unaffected. Furthermore, the relative difference of $h$ and $k$ is
  unchanged, so no further iterations are introduced.
\item Lines 11-12 finds the quotient and remainder using Equation
  (\ref{eq:defquo}) with $\delta=0$, some big integer multiplication method
  \texttt{MUL}, and some absolute subtraction method
  \texttt{SUB}$_{\mathtt{abs}}$.
\item Lines 14-16 checks the value of $\delta = \{0,1\}$ based on the nonsensicality
  of the remainder, and adjusts the quotient and remainder accordingly.
\end{enumerate}

\begin{figure}
{
\hrule\vspace*{-0.4ex}
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=pseudo,frame=,escapeinside={!}{!}]
-- finds `k` s.t. !$\green \texttt{B}^{\texttt{k}} \leq \texttt{v} < \texttt{B}^{\texttt{k}+\texttt{1}}$!
fun FINDK v =
  k = (sizeof v) - 1
  while v[k] == 0 do
    k -= 1
  return k

-- finds `p` s.t. !$\green \texttt{v} < \texttt{B}^{\texttt{p}}$!
fun PREC v =
  return FUNDK v + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=pseudo,firstnumber=11,frame=,escapeinside={!}{!}]
-- finds `h` s.t. !$\green \texttt{u} \leq \texttt{B}^{\texttt{h}}$!
fun FINDH u =
  h = FINDK u
  if u[h] == 1
  then return u
  else return u + 1

-- computes !$\green ( \texttt{v}\cdot \texttt{w})~\texttt{rem}~\texttt{B}^{\texttt{L}}$!
fun MULMOD v w L =
  return take L (MUL v w)
\end{lstlisting}
\end{minipage}\vspace*{-0.8ex}
\hrule
}
\caption{\footnotesize Helpers for Watt's division algorithm, where \texttt{MUL}
  is some big integer multiplication method.}
\label{divhelpers}
\end{figure}

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing $u~\mathtt{quo}~v$ and $u~ \mathtt{rem}~ v$ using Definition \ref{def:quo}, where \texttt{MUL} is a big integer multiplication method, \texttt{SUB} subtraction method, \texttt{ADD} addition method, and with helpers from Listing \ref{divhelpers}.},label={div}]
fun DIV u v =
  -- 1. Find assumptions
  h = FINDH u
  k = FINDK v
  -- 2. Avoid non-terminating loop
  if k == 1 then u = shift 1 u
                 v = shift 1 v
                 h += 1
                 k += 1
  -- 3. Find quotient and remainder
  q = shift (-h) (MUL u (SHINV h k v))
  r = SUB!$_{\texttt{abs}}$! u (MUL q v)
  -- 4. Adjust for !\green$\delta$!
  if (r >= v) then q = ADD q 1
                   r = SUB r v
  return (q, r)
\end{lstlisting}

Next, we present the refinement method used by \texttt{SHINV}. The pseudocode is
in Listing \ref{refine} and contains no alterations to the original formulation
in \cite{watt2023efficient}. It use the method \texttt{STEP} to compute a Newton
iteration, which we shortly discuss when presenting Listing \ref{step}. This
method expands the specialized Newton iteration with two concepts;
\textit{shorter iterates} and \textit{divisor prefixes}. Shorter iterates is the
idea that not all digits matters in the intermediate results between
iterations. Since the precision roughly doubles, only the leading $l$ digits of
the intermediate results contributes to the refinement at each iteration. Line 5
computes the number of leading digits relevant for the current iteration. It
effectively allows us to truncate the size of the big integers in the
\texttt{STEP} function, rather than doing each step in full size, s.t.\ the size
of the integers in each Newton step roughly doubles at each iteration.

In turn, this introduces the need for \textit{guard digits}, because the
truncated-sized steps may differ from the full-sized steps, but only in the two
least significant digits. Hence, we use $2$ guard digits as defined in line 2,
and shift the approximate $w$ accordingly.

Lastly, divisor prefixes is the idea that when the divisor $v$ is large relative
to the shifted inverse approximated at each iteration, some of the leading
digits of $v$ does not contribute to the result of the iteration step. Instead,
we use a prefix of $v$ to further truncate the size of the big integers at each
step. This process is imprecise too, but is defined s.t.\ the 2 guard digits
accounts for the imprecision. The scaling of $v$ is determined in line 6.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for refining the shifted inverse approximate $w$ of $l$ correct leading digits, using the Newton iterate step function \texttt{STEP} of Listing \ref{step}, where the computational work of finding iterates is reduced by using shorter iterates and divisor prefixes.},label={refine}]
fun REFINE v w h k l =
  g = 2          -- guard digits to account for shorter
  w = shift g w  -- iterate and divisor prefix inexactness
  while h - k > l do
    n = min l (h - k + 1 - l)   -- `n` is amount to grow the iterate
    s = max 0 (k - 2*l + 1 - g) -- `s` is amount to scale `v` with
    w = shift (-1) (STEP (k + l + n - s + g) (shift (-s) v) w n l g)
    l += n - 1                  -- `l` is amount of correct leading digits
  return shift (-g) w
\end{lstlisting}

Next up is the Newton step function \texttt{STEP}. Its pseudocode is in Listing
\ref{step}. This is where most of the computational work lies since it contains
two multiplications. The function computes
$\mathit{step}(h,v,w,n) = w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$ as
given by Watt in \cite{watt2023efficient}. From the calling procedure of
\texttt{STEP} in \texttt{REFINE}, we get that the function corresponds to
$w\cdot B^l + \lfloor w \cdot (B^{l} - B^{-k+s-g} \cdot \lfloor v\cdot B^{-s} \rfloor \cdot w)\rfloor$, which satisfies the
properties of divisor prefixes and shorter iterates, as proofed by Watt. We have made
no alterations to the original function formulation, except for explicitly
handling sign and magnitude of the function \texttt{POWDIFF}.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing a Newton step of the refinement method in Listing \ref{refine} for big ints $v$ and $w$ defined as $\mathit{step}(h,v,w,n) = w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$. $h$ is the parameter and $n$ the number of digits to correctly refine in this step. $l$ is the number of leading digits currently correct and $g$ is the amount of guard digits added by the refinement method -- which are both passed down to and enables optimizations in the function \texttt{POWDIFF} given in Listing \ref{powdiff} that computes $B^{h-n}-v\cdot w$. \texttt{MUL} is a big integer multiplication method, \texttt{SUB}$_{\mathtt{abs}}$ is absolute subtraction of big integers, and \texttt{ADD} is addition of big integers.},label={step}]
fun STEP h v w n l g =
  -- 1. Compute !$\green \texttt{B}^{\texttt{h}- \texttt{n}}- \texttt{v} \cdot \texttt{w}$!
  (pwd, sign) = POWDIFF v w (h-n) (l-g)
  -- 2. Compute and return !$\green\texttt{w} \cdot \texttt{B}^{\texttt{n} - \texttt{h}}+ \lfloor \texttt{w} \cdot ( \texttt{B}^{\texttt{h}}- \texttt{v}\cdot \texttt{w})\cdot \texttt{B}^{\texttt{2n} - \texttt{h}}\rfloor$!
  if sign
  then return SUB!$_{\texttt{abs}}$! (shift n w) (shift (2*n - h) (MUL w pwd))
  else return ADD!$_{\phantom{\texttt{abs}}}$! (shift n w) (shift (2*n - h) (MUL w pwd))
\end{lstlisting}

Lastly is the function \texttt{POWDIFF}. The term $B^h-v \cdot w$ appears in each
iteration step. While it can be computed straightforward, Watt increases the
efficiency by using close products. The idea is that in cases where the product
$v\cdot w$ is close to $B^h$ by a factor of $|B^h- v\cdot w|\leq B^L, L < h$, only the
lower $L$ digits of the product $v \cdot w$ is needed. Hence, we can use a truncated
multiplication of size $L$ rather than the size of $v$ and $w$. Listing
\ref{powdiff} shows the pseudocode for this function:
\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode computing $\mathit{powdiff(v,w,h)}=B^{h}- v \cdot w$ efficiently using close products and helpers from Listing \ref{divhelpers}, where $l$ is number of correct leading digits in $w$, \texttt{MUL} is a big integer multiplication method, and \texttt{SUB} is signed big integer subtraction, with \texttt{false} representing unsigned and \texttt{true} signed.},label={powdiff}]
fun POWDIFF v w h l =
  L = (PREC v) + (PREC w) - l + 1
  -- Constant case where !$\green\texttt{v}\cdot \texttt{w} = \texttt{0}$!, so result is B!$^{\green\texttt{h}}$!
  if (v == 0) || (w == 0) then return (B!$^{\texttt{h}}$!, false)
  -- Worst case where the multiplication !$\green\texttt{v}\cdot \texttt{w}$! is in full size
  if L >= h               then return SUB B!$^{\texttt{h}}$! (MUL v w)
  -- Close product case where only the lower L digits of !$\green\texttt{v}\cdot \texttt{w}$! is needed
  P = MULMOD v w L
  if P      == 0 then return (P, false)
  if P[L-1] == 0 then return (P, true)
  return SUB B!$^{\texttt{L}}$! P
\end{lstlisting}

Thus, by using our defined \texttt{DIV}, the revised \texttt{SHINV}, and the big
integer specialized \texttt{REFINE}, \texttt{STEP}, \texttt{POWDIFF} and helper
functions, we achieve an exact division operator for big integers. It relies on
arithmetic operators for addition, subtraction, and multiplication of big
integers (such as \textit{badd}, \textit{bsub}, and \textit{convmul}), but is
independent from the implementation of said operators. Hence, it is possible to
e.g.\ use different operators for different input sizes. The asymptotics is
dominated by the choice of multiplication operator (given that the addition and
subtraction is efficiently implemented). The iterative refinement process takes
$\lceil \log (h-k) \rceil$ iterations, and each iteration step runs two
multiplications. Due to the structure and optimizations of the refinement
process, the work is $O(M(m))$, where $M(m)$ is the work of the chosen
multiplication operator and $m$ is the size of the input integers
\cite{watt2023efficient}.




\subsection{General Reflections and Prototyping}
\label{subsec:divproto}

This section discusses some concerns and solutions about the presented
algorithm. We wrote a sequential low-level prototype of the algorithm in C to
better understand its adaptation of our big integer representation. In its
creation, we discovered multiple interesting subject matters -- some which are
directly included in the pseudocode given in section \ref{subsec:divalg}, and
some which we now present.

\paragraph{Initial Approximation}
The initial approximation is found in step II of Listing \ref{shinv}. It gathers
the three leading digits of $v$ in $V$ and then finds $B^4-V$, giving a result
of four digits. It then divides those four digits by $V$, giving a result of
either one or two digits. Hence, the quadruple base type \texttt{qint\_t} is
necessary to efficiently compute the initial approximation with register
arithmetic. This restricts a CUDA implementation to base \texttt{uint32\_t} and
Futhark to \texttt{u16}. In C, this process corresponds to Listing \ref{initC}:
\begin{lstlisting}[language=CPP,caption={\footnotesize C code to efficiently form the initial approximation of \texttt{SHINV} in base \texttt{uint\_t} of \texttt{bits} bits and quad type \texttt{quint\_t} of $4\cdot$\texttt{bits} bits.},label={initC},escapeinside={!}{!}]
quint_t V = (quint_t) v[k-2];                        // V  = v[k-2]
V +=       ((quint_t) v[k-1]) << bits;               // V += v[k-1] !$\green\cdot$! B!$\green ^{\texttt{1}}$!
V +=       ((quint_t) v[k])   << (2*bits);           // V += v[k]   !$\green\cdot$! B!$\green ^{\texttt{2}}$!

quint_t r = (((quint_t) 0) - V) / V + ((quint_t) 1); // r = (B!$\green ^\texttt{4}$! - V) / V + 1

w[0] = (uint_t) r;                                   // w = r 
w[1] = (uint_t) (r >> bits);                         // (assuming w was 0)
\end{lstlisting}

\paragraph{Base Powers}
These are prominent throughout the algorithm, and comes in a multitude of
usecases. When multiplied, they take the shape of a \texttt{shift} operator, as
already incorporated into the pseudocode. In the \texttt{POWDIFF} function, they
are returned or otherwise used directly, and hence, require construction in a
new memory space.

Remaining is the special cases of step I in the \texttt{SHINV} function. The
base powers are operands to comparisons that express something structural about
the divisor $v$. Hence, they can be integrated in said comparisons, avoiding
their construction.  E.g.\ consider the second case $v > B^h$. This optimizes to
the check: $\exists i\in \mathbb{N}.~(h<i<m \land v[i] \neq 0) \lor (h = i<m \land v[i] > 1)$.

(On a similar note, the multiplication by single precision of the third special
case $2v > B^h$ should be treated as $v > B^h/2$ and integrated in the
comparison as well.)

\paragraph{Preallocating Memory}
Throughout this thesis, the big integer arithmetic has been considered to preserve
the input shape on output. The efficiency of this algorithm require fine control
over the size of operands at each iteration, and hence, we need to adjust the
size parameter of inputs and outputs, according to the iteration
number. Furthermore, it is ideal to preallocate a memory region large enough to
hold the biggest intermediate value of the refinement, rather than periodically
doubling the memory regions of the operands. From the analysis in Watt's paper
\cite{watt2023efficient}, the size of the operands at iteration $i$ is at most
$2^i$. Since we have $\lceil \log (h-k) \rceil$ iterations, we get the maximum operand
size $2^{\lceil \log (h-k) \rceil}$.


\paragraph{Guard Digits}
In order to get our prototype to validate, we adjusted the amount of guard
digits in the refinement method from $2$ to $m$, with $m$ being the size of the
inputs. Currently, we are not aware whether this is related to the algorithm or
an error in the prototype.

\subsection{Parallelization and Futhark Implementation}
\label{subsec:divfut}

While Section \ref{subsec:divproto} focused on general reflections, this section
focuses on concerns and solutions regarding parallelization and Futhark
implementation. The implementation we developed is not efficient and only
partially validates, but it illustrates some of the complexities involved in a
parallel adaptation of the algorithm -- which we will now present.

\paragraph{Multiple Instances per Block}
In our other arithmetics we incorporate multiple big integer instances per CUDA
block, which are then handled by segmented operations. It allows to maintain the
efficiency of the arithmetics when processing small integers. However, Watt's
algorithm contains branching of the following forms:

Most apparent are the special cases of \texttt{SHINV}, directly returning from
the function. Then we have the close product optimization in \texttt{POWDIFF},
and the divisor prefixes and shorter iterates optimizations in \texttt{REFINE}
and \texttt{STEP}, which computes multiplications of various length inputs,
based on the precision of the integers. Lastly, the number of sequential Newton
iterations in the refinement process directly depends on the precision of the
inputs too.

Hence, the division algorithm is not suitable for segmented use, i.e.\ it is
inefficient to process multiple instances per block using this algorithm.

\paragraph{Work Balancing}
The interest is to implement the algorithm at CUDA block-level and in a single
kernel. This restricts the number of threads per integer, but more importantly,
it restricts the implementation to only use one execution configuration. In
turn, the kernel must be able to handle all the various length arithmetics
within the specified configuration.

A naÃ¯ve solution is to spawn the kernel with the exact number of threads needed
to efficiently run the arithmetic of greatest input length. However, this
results in threads idling for arithmetics of shorter length, overall decreasing
the efficiency. Likewise, if the kernel spawns with an inadequate number of
threads, the sequentialization factor of the arithmetic of the greatest length
input may exhaust registers and local memory, overall decreasing efficiency.

An efficient solution requires running the big integer arithmetic in the kernel
with varying degrees of intra-thread sequentialization, as well as finding the
optimal kernel configurations.

\paragraph{Shift Operator}
Shifting a big integer in parallel is very efficient and equivalent to a map, as
seen on the Futhark code in Listing \ref{shiftfut}. We can transform the
operator to be in-place in CUDA by splitting the map: Fetch the designated digit
$\shortrightarrow$ synchronize $\shortrightarrow$ write the digit.
\begin{lstlisting}[language=futhark,caption={\footnotesize Shift operator (Definition \ref{def:shifts}) in Futhark from file \texttt{helper.fut}.},firstnumber=96,label={shiftfut}]
def shift [m] (n: i64) (u: [m]ui) : [m]ui =
  map (\ i -> let off = i - n -- positive for right, negative for left
              in if off >= 0 && off < m then u[off] else 0) (iota m)
\end{lstlisting}

\paragraph{Division by Single Precision}
The first special case of \texttt{SHINV} where $v<B$ requires quotient by a
single precision integer (digit). The intuition follows from Definition
\ref{def:bigints} and states that the quotient of a size $m$ integer $u$ by
digit $d$ in base $B$ can be computed as:
\begin{equation}
  \label{eq:divsing}
  q_i = \dfrac{\sum_{j=i}^{m-1} u_j \cdot B^{j-i}}{d}~ \mathtt{rem}~ B
\end{equation}
E.g.\ consider the decimal number 300 divided by 4: We have
$q_0 = (300 / 4)~ \mathtt{rem}~ 10 = 5$, $q_1 = (30 / 4)~ \mathtt{rem}~ 10 = 7$
and $q_2 = (3 / 4)~\mathtt{rem}~10 = 0$, giving the number 75. This approach
includes the big integer $u$ and does not fit in a word. However, Equation
\ref{eq:divsing} can be rephrased in terms of the standard long division
(grade-school) method. The method formalizes to computing the partial quotient
$q_{i\in\{0,..,m-1\}}$ using the partial remainder $r_{i\in\{0,..,m\}}$ as follows:
\begin{align}
  q_i &= \left( r_{i+1} \cdot B + u_i\right)~ \mathtt{quo}~ d\\
  r_i &= \begin{cases} \left( r_{i+1} \cdot B + u_i\right)~ \mathtt{rem}~d & \text{if}~i<m \\ 0 & \text{otherwise} \end{cases}
\end{align}
The intermediate results of this approach fits in a double word. This algorithm
is a simple solution (opposed to e.g.\ GMP's) and the one occupying our
sequential prototype. However, it is inherently right-to-left
sequential and unsuitable for parallel computation.

We recognise three approaches:
\begin{enumerate}
\item The long division algorithm may be parallelized over a scan (similarly to
  addition).\label{divbysing1}
\item Computing an inverse (e.g.\ a whole shifted inverse by a method similar to
  \texttt{SHINV}) may be efficient in parallel, but requires a multiplication
  afterwards.\label{divbysing2}
\item Shifting both $u$ and $v$ by two when $k = 0$ (similarly to the shift by
  one when $k=1$).\label{divbysing3}
\end{enumerate}

The potentialities of approach \ref{divbysing1} and \ref{divbysing2} are unknown
to us and beyond the scope of this thesis. Hence, we use approach
\ref{divbysing3} for our parallel Futhark implementation.

\paragraph{Assumptions, Comparisons, and Signed Subtraction}
The algorithm features multiple comparisons of big integers, all of which
parallelizes to map-reduce compositions. First, consider the special cases of
\texttt{SHINV}. As mentioned in Section \ref{subsec:divproto}, they can be
optimized to a unary comparison over the big integer. Following the example of
that section, the second special case $v > B^h$ parallelizes to Listing
\ref{gtbpow}:
\begin{lstlisting}[language=futhark,caption={\footnotesize Futhark function to check $u > B^i$ in parallel for big integer $u$ in base $B$ from file \texttt{div.fut}.},label={gtbpow},firstnumber=29]
def gtBpow [m] (u: [m]ui) (i: i64) : bool =
  map2 (\ x j -> (x > 1 && j == i) || (x > 0 && j > i) ) u (iota m)
  |> reduce (||) false
\end{lstlisting}
Next, we have the equalities involved with the \texttt{POWDIFF}
function. Equality of big integers corresponds to equality between digits, which
parallelizes straightforward. Then there are the structural assumptions of big
integers, written sequentially as the helpers \texttt{FINDK}, \texttt{FINDH},
and \texttt{PREC} of Figure \ref{divhelpers}. They parallelize to a map-reduce
composition that finds the greatest nonzero index. E.g.\ Listing \ref{findk}
shows a parallel \texttt{FINDK}, where the map-reduce is equivalent to the
\textit{max} function over the indices of nonzero digits in the input:
\begin{lstlisting}[language=futhark,caption={\footnotesize Futhark function to find $i$ for big integer $u$ in base $B$ s.t.\ $B^i \leq u < B^{i+1}$ from file \texttt{div.fut}.},label={findk},firstnumber=39]
def findk [m] (u: [m]ui) : i64 =
  map2 (\ x i -> if x != 0 then i else 0 ) u (iota m)
  |> reduce (\ acc i -> if i != 0 then i else acc ) 0
\end{lstlisting}

Penultimately, the subtraction presented in Section \ref{subsec:sub} is
unsigned, yet \texttt{POWDIFF} requires signed subtraction. Extending the
subtraction to signs is trivial, achieved by determining the relation between
the operands. For this purpose, we use the general big integer `$<$` comparison
of Listing \ref{lt}. The map in line 84 encodes whether the pairwise digits of
the inputs are either `$<$` or `$=$`. Line 85 then reduce with the following
operator:
\begin{equation}
  \label{eq:lt}
  \tup{\mathit{l1}}{\mathit{e1}} \odot \tup{\mathit{l2}}{\mathit{e2}} \coloneq \tup{\mathit{l2} \lor (\mathit{e2} \land \mathit{l1})}{\mathit{e1} \land \mathit{e2}}
\end{equation}
The rationale is: If the first operand is less than the second operand in the
most significant digits, then the whole integer is less than -- if it is equal in
the most significant digits, then it is decided in the least significant
digits. The left-associative neutral element of $\odot$ is
$\tup{\mathtt{False}}{\mathtt{True}}$. Proof of associativity and neutral
element are included in Appendix \hyperref[app:C]{C}.

\begin{lstlisting}[language=futhark,caption={\footnotesize Futhark function to check $u < v$ in parallel for big integers $u$ and $v$ from file \texttt{helper.fut}.},label={lt},firstnumber=83]
def lt [m] (u: [m]ui) (v: [m]ui) : bool =
  map2 (\ x y -> (x < y, x == y) ) u v
  |> reduce (\(l1,e1) (l2,e2) -> (l2 || (e2 && l1), e1 && e2)) (false,true)
  |> fst -- `fst` extracts the first tuple field
\end{lstlisting}

Lastly, we have the `$\geq$` associated with finding $\delta$ (line 14 of Listing
\ref{div}). This can be done efficiently by negating the result of the `$<$`
operator of Listing \ref{lt} above.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
