\section{Division}
\label{sec:div}

The last of the basic arithmetics is division, and it is far more complicated
than the others. We say that the division is \textit{exact} when the divisor
precisely divides the dividend. When the division is not exact, the result is
ordinarily represented by a fraction -- yet we do not desire to leave the domain
of integrals. Instead, we use the notion of \textit{quotient} and
\textit{remainder} commonly present in integer semantics:
\begin{align}
  u~\mathtt{quo}~v &\coloneq \lfloor u/v \rfloor\\
  u~ \mathtt{rem}~v &\coloneq u - \left( u~\mathtt{quo}~v \right)\cdot v
\end{align}
Usually, the quotient is associated with the division operator, and the
remainder with the modulus operator. Our division computes both values and
returns them as a pair.

A common way to reason about division is to multiply the dividend with the
inverse of the divisor, also called the reciprocal. GMP use reciprocals for
division by single precision, but since reciprocals are expensive to compute,
their basecase division use Knuth's algorithm for long division, also known as
\textit{grade-school} division \cite{GMP, knuth97}. This algorithm is inherently
sequential: It iteratively produces the result by finding one correct digit per
iteration, and thus, hints at a linear depth unfit for GPGPU. As a result, we
focus on algorithms using the inverse of the divisor.

A well-known algorithm to find reciprocals is the Newton-Raphson method. It
takes an initial approximation, and through a series of iterative steps (also
called Newton iterations), refines the precision of the approximation. While it
runs a number of inherently sequential iterations too, the precision of the
approximation roughly doubles at each iteration, hinting at a logarithmic depth
and making it more suitable for GPGPU than long division.

However, it presents a new hurdle w.r.t.\ the internal representation of both
the inverse and the intermediate approximations in iteration steps. One solution
is to use fractions internally and convert back to integers before returning the
output. The downsides to this solution is the potential loss of precision when
using floating points (i.e.\ it will no longer be an exact arithmetic) and the
overhead of converting between representations.

Instead, we use Watt's efficient and exact arithmetic algorithm for computing
quotients, presented in \cite{watt2023efficient}. The prerequisite of the
algorithm is the existence of a shift operation for the chosen data type -- which
is an efficient operation for integers -- and a multiplication method given as an
argument. The intuition is to utilize the shift operation in order to avoid the
domain change associated with computing the inverse, by instead computing what
is referred to as the \textit{whole shifted inverse}.

This section is structured as follows: In \ref{subsec:divalg} we give a detailed
introduction to the algorithm formulated by Watt in \cite{watt2023efficient}. We
also present a revision to the algorithm regarding an unconsidered corner case,
and specialize it to the domain of big integers. In \ref{subsec:divproto} we
further discuss its adaptability w.r.t.\ big integers, and raise concerns and
solutions based on a sequential prototype of the algorithm written in C. It
serves to fully understand the complexities involved in adapting the algorithm
to big integers. Lastly, in \ref{subsec:divfut} we give an overview on how to
parallelize the algorithm based on Futhark.

\subsection{Algorithm}
\label{subsec:divalg}

Before discussing the exact division algorithm, we introduce a new notation: The
\textit{precision} of a big integer (denoted by $p$) refers to the number of
digits without leading zeroes. E.g.\ the integer $\arr{1,2,0}$ has size $m=3$
and precision $p=2$.

We now give the intuition behind the algorithm defined by Watt in
\cite{watt2023efficient}, and refer to the original paper for proofs and a
generic version. The foundation of the algorithm is a whole shift operator and a
whole shifted inverse operator:

\begin{definition}[whole shift and whole shifted inverse of big integers]\label{def:shifts}
  We define a $n \in \mathbb{Z}$ whole shift and $n' \in \mathbb{N}$ whole shifted inverse of big
  integers $u\in \mathbb{N}$ and $v\in \mathbb{N}^{+}$ in base $B$ as:
  \begin{equation}\label{eq:shifts}
    \mathtt{shift}_n~u \coloneq \lfloor u \cdot B^n \rfloor \quad \qquad \mathtt{shinv}_{n'}~v \coloneq \lfloor B^{n'}/ v \rfloor
    \end{equation}
\end{definition}

A shift in our array-oriented representation behaves similarly to a binary
system arithmetic shift, e.g.\ $\mathtt{shift}_1~\arr{1,2,3} = \arr{0,1,2}$ and
$\mathtt{shift}_{-1}~\arr{1,2,3} = \arr{2,3,0}$. The shifted inverse behaves as
an inverse that has been shifted, which follows from the its definition:
\begin{equation}
\label{eq:shiftinvex}
\mathtt{shinv}_{n'}~v = \lfloor B^{n'}/ v \rfloor = \lfloor \dfrac{1}{v} \cdot B^{n'} \rfloor = \mathtt{shift}_{n'}~\dfrac{1}{v}
\end{equation}
Now, suppose the fractional part of $v$ consists of $m'$ digits -- then, given it
is shifted by some $n'>m'$, the shifted inverse essentially behaves as a
fractional representation that has been shifted into our domain. E.g.\ decimal
system, the inverse of the number $4$ is $0.25$, which has a fractional part of
precision $2$, and so picking $n'=2$ gives us
$\mathtt{shinv}_2~4 = \mathtt{shift}_2~0.25 = 25$, which does not require
fractions to represent.

Picking such a $n'$ is not trivial, as is evident from recurring digits (e.g.\
\nicefrac{1}{3}). However, for division, it is good enough to pick $n'=h$ where
$h$ is the precision of the dividend, proven by Watt in
\cite{watt2023efficient}. E.g.\ the decimal division $10~ \mathtt{quo}~3$, the
dividend has precision $2$ and so we find the shifted inverse
$\mathtt{shinv}_2~3= \mathtt{shift}_2~\nicefrac{1}{3} = 33$. Then we multiply
$33\cdot10 = 330$. Now, since the inverse was shifted by 2, we must shift it by
$-2$ (i.e.\ it was multiplied with $B^2$, so we multiply it by $B^{-2}$), and
get $\mathtt{shift}_{-2}~330 = 3$.

Before we define how to compute the shifted inverse, let us consider Example
\ref{ex:bigintdiv}, showing the intuition behind the above process for big
integer.\bigskip

\begin{example}[big integer division by whole shifted inverse]\label{ex:bigintdiv}
  Suppose we have the integer $u=\arr{1,2,3}$ in base $B=2^{32}$ and wish to
  divide it by the integer $v=\arr{1,1,0}$ in base $B$. Since $u$ is of
  precision $p=3$, we shift the inverse of $v$ by $3$ (using a calculator for
  now):
\begin{equation}
\label{eq:3}
\mathtt{shinv}_3~\arr{1,1,0} = \arr{0,4294967295,0}
\end{equation}
We can then multiply $u$ with the shifted inverse (expanding the result size),
and get:
\begin{equation}
  \label{eq:4}
  \arr{1,2,3}\cdot\arr{0,4294967295,0} = \arr{0,4294967295,4294967294,4294967294,2}
\end{equation}
Now, since the fractional part of the inverse was "shifted into our domain" by
3, we shift the result by $-3$ (and compress it to the original size):
\begin{equation}
  \label{eq:5}
  \mathtt{shift}_{-3}~\arr{0,4294967295,4294967294,4294967294,2} = \arr{4294967294,2,0}
\end{equation}
The correct answer is $\arr{4294967295,2,0}$, so the method is off by one.
\end{example}\bigskip

In the given example, the result is not precise -- which is an accommodated
byproduct of using the whole shifted inverse: The method approximates the result
by a difference of one at most, allowing us to mechanically adjust the result.
The formal definition given by Watt in Theorem 1 of his paper
\cite{watt2023efficient} is as follows:

\begin{definition}[quotient of big integers by whole shifted inverse]\label{def:quo}
  For the base $B$ big integers $u$ and $v$ and some $h\in \mathbb{N}$ s.t.\
  $u \leq B^h$, the quotient of $u$ by $v$ is:
  \begin{equation}
    \label{eq:defquo}
    u~\mathtt{quo}~v = \mathtt{shift}_{-h}~ (u \cdot \mathtt{shinv}_h~v) + \delta,\quad \text{where~} \delta \in \{0,1\}
  \end{equation}
\end{definition}

The challenge now lies in computing \texttt{shinv}. The remaining of this
section is partitioned in two parts. Part \ref{subsubsec:divalg1} details the
algorithm to compute the whole shifted inverse (\texttt{shinv}) of a big
integer, and part \ref{subsubsec:divalg2} defines a division algorithm using the
whole shifted inverse.

\subsubsection{Computing the whole shifted inverse}\label{subsubsec:divalg1}
The algorithm given by Watt (Algorithm 1 in \cite{watt2023efficient}) computes
the whole shifted inverse of an integer, by using a Newton iteration over
integers and specialized to the base, s.t.\ it can use shifts rather than
fractions. We adapt this algorithm to our big integer representation, and make
a revision to it. The complete algorithm is listed in Figures \ref{shinv} and
\ref{shinvcont}. It computes \texttt{shinv}$_h~v$ for $v$ in base $B$, under the
assumption that $B^k \leq v < B^{k+1}$. We contribute to the algorithm with the
extra assumption that $k\neq 1$. We show how to find and enforce these assumptions
in part \ref{subsubsec:divalg2}. We now present each function step by step.

\begin{figure}
\begin{lstlisting}[language=pseudo,escapeinside={!}{!}]
!{\red\hypersetup{allcolors=Crimson}$\bullet$ \texttt{ Computes \texttt{shinv}$_h~v$, i.e.\ $\lfloor B^{h}/ v \rfloor$ (Definition \ref{def:shifts}), where $v$ is a base $B$ big integer s.t.\ $B^k \leq v < B^{k+1}$ and $k\neq 1$, and \texttt{quo}$_{\mathtt{digit}}$ and \texttt{*}$_{\mathtt{digit}}$ denotes a single precision operand.}}!
fun SHINV h k v =
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvI}}! Handle special cases
  if v          <  B!$^{\phantom{\texttt{h}}}$! then return B!$^\mathtt{h}$! quo!$_{\texttt{digit}}$! v[0]
  if v          >  B!$^\texttt{h}$! then return 0
  if (v *!$_{\texttt{digit}}$! 2) >  B!$^\texttt{h}$! then return 1
  if v          == B!$^\mathtt{k}$! then return B!$^{\texttt{h}-\texttt{k}}$!
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvII}}! Find a two digit initial approximation !\green$w$! for the shifted inverse
  V = v[k-2] + (v[k-1] * B) + (v[k] * B!$^{\texttt{2}}$!)
  w = ((B!$^{\texttt{4}}$! - V) / V) + 1
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvIII}}! Refine until sufficient (see below), which it may already be
  if h - k <= 2 then return shift (h - k - 2) w 
  return REFINE v w h k 2

!{\red\hypersetup{allcolors=Crimson}$\bullet$ \texttt{Refines the approximation $w$ of the $h$-shifted inverse of $v$, currently consisting of $l$ correct leading digits, where the total computational work is reduced by using shorter iterates and divisor prefixes. In the function, $g$ denotes the amount of guard digits to account for the inexactness of using shorter iterates and divisor prefixes. $n$ is number of digits to grow the correct part of the approximation in each iteration, w.r.t. shorter iterates. $s$ is the amount of digits to scale $v$ with w.r.t. divisor prefixes, in order to obtain a prefix that has at most $g$ digits of error. The Newton step is then, for all but the last iteration:$$w = w\cdot B^l + \lfloor w \cdot (B^{l} - B^{-k+s-g} \cdot \lfloor v\cdot B^{-s} \rfloor \cdot w)\rfloor$$In the last iteration, it is instead:$$w = w\cdot B^{h - k + 1 - l} + \lfloor w \cdot (B^{h - k + 1 - l} - B^{h - 2k + 1 - 2l + s - g} \cdot \lfloor v\cdot B^{-s} \rfloor \cdot w)\rfloor$$}}!
fun REFINE v w h k l =
  -- guard digits to account for the inexactness of using shorter iterates and divisor prefixes (at most !\green$B$! from being correct, so 2 guard digits)
  g = 2
  w = shift g w
  while h - k > l do
    -- !$\green n$! is amount to grow the correct part of the approximation in this iteration (w.r.t. shorter iterates). For the last iteration we get !\green$n = h - k + 1 - l$!, but for all others we get !\green$n = l$! (doubling the precision).
    n = min l (h - k + 1 - l)
    -- !$\green s$! is amount to scale !$\green v$! with (w.r.t. divisor prefixes)
    s = max 0 (k - 2*l + 1 - g)
    -- take a Newton step (see below)
    w = shift (-1) (STEP (k + l + n - s + g) (shift (-s) v) w n l g)
    -- !$\green l$! is amount of correct leading digits after the step (i.e. one short for doubling, except for the last iteration)
    l += n - 1
  return shift (-g) w

!{\red\hypersetup{allcolors=Crimson}\texttt{Continued in Figure \ref{shinvcont}} on next page $\ldots$}!
\end{lstlisting}
  \caption{\footnotesize Algorithm to compute \texttt{shinv}$_h~v$, where $v$ is a base $B$ big integer s.t.\ $B^k \leq v < B^{k+1}$ and $k\neq 1$, adapted to big integers from Algorithm 1 by Watt in \cite{watt2023efficient}, continued on the next page in Figure \ref{shinvcont}.}
  \label{shinv}
\end{figure}
\begin{figure}
\begin{lstlisting}[language=pseudo,escapeinside={!}{!},firstnumber=32]
!{\red\hypersetup{allcolors=Crimson}\texttt{$\ldots$ Continuation of Figure \ref{shinv}} from previous page.}!

!{\red\hypersetup{allcolors=Crimson}$\bullet$ \texttt{Takes a Newton step for big integers $v$ and $w$, defined as $$\mathit{step}(h,v,w,n) \coloneq w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$$Here, $h$ is the parameter to shift the inverse, and $n$ the number of extra digits to refine in this step (since the last iteration does not double the correct precision). $l$ is the number of leading digits currently correct, and $g$ is the amount of guard digits added by the refinement method -- both of which are passed down to \texttt{POWDIFF} to enable optimizations (see below). \texttt{MUL} is a big integer multiplication method, \texttt{SUB}$_{\mathtt{abs}}$ an absolute subtraction method, and \texttt{ADD} an addition method.}}!
fun STEP h v w n l g =
  -- 1. Compute !$\green \texttt{B}^{\texttt{h}- \texttt{n}}- \texttt{v} \cdot \texttt{w}$!
  (pwd, sign) = POWDIFF v w (h-n) (l-g)
  -- 2. Compute and return !$\green\texttt{w} \cdot \texttt{B}^{\texttt{n}}+ \lfloor \texttt{w} \cdot ( \texttt{B}^{\texttt{h}-\texttt{n}}- \texttt{v}\cdot \texttt{w})\cdot \texttt{B}^{\texttt{2n} - \texttt{h}}\rfloor$!
  if sign
  then return SUB!$_{\texttt{abs}}$! (shift n w) (shift (2*n - h) (MUL w pwd))
  else return ADD!$_{\phantom{\texttt{abs}}}$! (shift n w) (shift (2*n - h) (MUL w pwd))

!{\red\hypersetup{allcolors=Crimson}$\bullet$ \texttt{Computes the following function efficiently using close products (i.e.\ we may sometimes truncate the length of the multiplication computing $v\cdot w$):$$\mathit{powdiff(v,w,h)}\coloneq B^{h}- v \cdot w$$ $l$ is number of correct leading digits in $w$, \texttt{MUL} is a big integer multiplication method, \texttt{SUB} is a signed big integer subtraction method (with \textit{false} representing unsigned and \textit{true} representing signed), and \texttt{MULMOD} and \texttt{PREC} is as defined below.}}!
fun POWDIFF v w h l =
  L = (PREC v) + (PREC w) - l + 1
  -- Best case where !$\green\texttt{v}\cdot \texttt{w} = \texttt{0}$!, so the result is B!$^{\green\texttt{h}}$!
  if (v == 0) || (w == 0) then return (B!$^{\texttt{h}}$!, false)
  -- Worst case where the multiplication !$\green\texttt{v}\cdot \texttt{w}$! is in full size
  if L >= h               then return SUB B!$^{\texttt{h}}$! (MUL v w)
  -- Close product case where only the lower L digits of !$\green\texttt{v}\cdot \texttt{w}$! is needed
  P = MULMOD v w L
  if P      == 0 then return (P, false)
  if P[L-1] == 0 then return (P, true)
  return SUB B!$^{\texttt{L}}$! P

!{\red\hypersetup{allcolors=Crimson}$\bullet$ \texttt{Finds the precision $p$ of big integer $v$, i.e.\ $v < B^p$.}}!
fun PREC v =
  p = (sizeof v) - 1
  while v[p] == 0 do
    p -= 1
  return p + 1

!{\red\hypersetup{allcolors=Crimson}$\bullet$ \texttt{Finds the first $L$ digits of the multiplication between big integers $v$ and $w$, i.e.\ $(v\cdot w)~ \texttt{rem}~B^{L}$, using some big integer multiplication method \texttt{MUL}.}}!
fun MULMOD v w L =
  return take L (MUL v w)
\end{lstlisting}
  \caption{\footnotesize Continuation of Figure \ref{shinv} from last page.}
  \label{shinvcont}
\end{figure}

\paragraph{\texttt{SHINV} (lines 1-13)}
The algorithm can roughly be divided into three steps:
\begin{enumerate}[label=\Roman*]
\item Handle the special cases (lines 4-7).\label{shinvI}
\item Find an initial approximation (lines 9-10).\label{shinvII}
\item Refine the initial approximation iteratively until it is sufficient (lines 12-13).\label{shinvIII}
\end{enumerate}

In step \ref{shinvI} we have four special cases. The first three cases
guarantee that $B < v \leq B^h/2$, which is proven a prerequisite for the initial
approximation method developed by Watt in \cite{watt2023efficient}, that picks
an initial approximation guaranteed to converge fast in the refinement process.
The first of these cases, is when $v$ only consists of a single digit, and we
use a division by single precision method instead. The next two cases is if
$v > B^h$ or $2v > B^h$ and so the inverse is $0$ and $1$, respectively.

The fourth special case guarantees that $v \neq B^k$. This is important because we
then know that $\lfloor B^{h}/ v \rfloor$ is a big integer of $h-k$ digits. E.g.\ consider
the example $h=2$ in decimal system (so $B^2=100$): If $v$ is $10$ (so $k = 1$),
the result is $100/10 = 10$ (2 digits). However, if $v < 10$ (i.e.\ $k=0$), then
$10 < 100/v$ (i.e.\ $h-k=2$ digits), and likewise, if $10 < v$ (i.e.\ $k=1$),
then $100/v < 10$ (i.e.\ of $h-k=1$ digit).

To rephrase: This case ensures that the refinement is sufficient once it has
produced $h-k$ correct digits. It is handled trivially by the rule
$x^a/x^b=x^{a-b}$.

Step \ref{shinvII} computes the initial approximation using the last three
digits of $v$, e.g.\ for $v$ of size $m$ we get $V= \arr{v[m-3],v[m-2],v[m-1]}$
in a positional notation.\footnote{Given our assumption $k \neq 1$, and the first
  special case in the previous step, where $k = 0$, it is guaranteed that $v$ is
  of sufficient size to compute such a $V$ (i.e.\ $v$ is at this point at least
  three digits).} It then finds the initial approximation as
$((B^4-V)/V)+1$. Since $V$ is three digits, we have that $B^4-V$ is four digits,
where the most significant digit is the maximum digit. (E.g.\ in decimal, $V$ is
at most $999$, and so $10^4-999 = 9001$.) Then, a four digit number divided by a
three digit number, where the fourth digit of the dividend is the maximum digit,
and the result is then incremented by one, gives us $2$ digit number. (E.g.\
consider again $(9001/999)+1=9+1=10$). As proven by Watt in
\cite{watt2023efficient}, this two digit approximation is a good initial
approximation, guaranteed to converge fast in the refinement method.

Step \ref{shinvIII} checks whether the initial approximation is sufficient,
i.e.\ if the shifted inverse (of $h-k$ digits) is a one or two digits result. If
more correct digits is needed (i.e.\ $h-k > 2$), it starts the refinement process
using the specialized Newton iteration.

\paragraph{\texttt{REFIINE} (lines 16-29)}
Watt presents three refinement methods with a varying degree of
optimizations. The method we use is the optimal (\texttt{refine3} of Algorithm 1
in \cite{watt2023efficient}), with no alterations to its original
formulation. This refinement method expands the specialized Newton iteration
with two concepts; \textit{shorter iterates} and \textit{divisor
  prefixes}. Shorter iterates is the idea that not all digits matter in the
intermediate results between iterations: Since the precision roughly doubles,
only the leading $l$ digits of the intermediate results contributes to the
refinement at each iteration, where $l$ denotes the current number of correct
leading digits. It effectively allows us to truncate the size of the big integer
multiplication in each Newton step (the \texttt{STEP} function discussed below),
rather than doing each step in the full size of the dividend. The size of the
multiplication roughly doubles with the iteration number. In turn, this
introduces the need for \textit{guard digits} (line 18), because the
truncated-sized steps may differ from the full-sized steps, but only in the two
least significant digits.

However, this is where our contributed assumption $k \neq 1$ is important. Shorter
iterates have the side effect of each iteration being exactly one digit short
from doubling the precision at each iteration. This means that the number of
correct leading digits, $l$, must be $\geq 2$. Thus, if $k = 1$ and we are in the
case $h-k>2$, then we start refining on $l=1$. In turn, one digit short of
doubling $l=1$ is $l=1$, and hence, the refinement process never increases the
precision and runs forever.

Lastly, divisor prefixes is the idea that, when the divisor $v$ is large in
relation to the shifted inverse approximated at each iteration, some of the
leading digits of $v$ does not contribute to the result of the iteration
step. Instead, we use a prefix of $v$ to further shorten the size of the
multiplications in each step. This process is imprecise too, but is defined
s.t.\ the 2 guard digits accounts for the imprecision. The factor to shift $v$
in order to obtain a prefix, is determined at line 24.

\paragraph{\texttt{STEP} (lines 35-41)}
This function is where most of the computational work lies, since it contains
two multiplications. The function computes
$w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$ for a given
$h$, $n$, and big integers $v$ and $w$ in base $B$, as given by Watt in
\cite{watt2023efficient}. It computes straightforward, except it uses the
function \texttt{POWDIFF} to handle $B^{h-n} - v \cdot w$ more efficiently, as
given by Watt. We have made no alterations to the original function formulation,
except for explicitly introducing a sign-magnitude representation of the term of
$B^{h-n} - v \cdot w$.

\paragraph{\texttt{POWDIFF} (lines 44-54)}
Lastly is the function \texttt{POWDIFF}. The term $B^h-v \cdot w$ appears in each
iteration step, and while it can be computed straightforward, Watt increases the
efficiency by using close products \cite{watt2023efficient}. The idea is that,
if the product $v\cdot w$ is close to $B^h$ by a factor of
$|B^h- v\cdot w|\leq B^L, L < h$, then only the lower $L$ digits of the product
$v \cdot w$ are needed, since the remaining are predetermined. Hence, we can use a
truncated multiplication of size $L$ rather than the size of $v$ and $w$. This
case is handled in lines 51-54. Formally, the multiplication for integers $v$
and $w$ corresponds to $(v \cdot w)~ \mathtt{rem}~B^L$, and is computed by the
function \texttt{MULMOD} in lines 64-65. In order to find such a $L$,
\texttt{POWDIFF} use the precision of its inputs (line 45), which is computed
straightforward by the function \texttt{PREC} in lines 57-61.

\subsubsection{Computing the big integer division}\label{subsubsec:divalg2}

We now present an algorithm for finding quotient and remainder of big integers
using Definition \ref{def:quo} and \texttt{SHINV} of Figure \ref{shinv} --
including how to enforce the assumption $k\neq 1$ of \texttt{SHINV} using shifts
(the necessity is discussed in part \ref{subsubsec:divalg1}). The Pseudocode for
this algorithm is in Figure \ref{div} and contains four steps:
\begin{enumerate}
\item Lines 3-4 compute the assumptions of the precision of the inputs
  straightforward using the functions \texttt{FINDK} (line 19-23) and
  \texttt{FINDH} (line 26-30).
\item Lines 6-9 handle the case $k=1$ by shifting both $u$ and $v$ by one. A
  shift is equivalent to a multiplication by definition, so the quotient is
  unaffected. Furthermore, the relative difference of $h$ and $k$ is unchanged,
  so no further iterations are introduced.
\item Lines 11-12 find the quotient and remainder using Equation
  (\ref{eq:defquo}) with $\delta=0$, some big integer multiplication method
  \texttt{MUL}, and some absolute subtraction method
  \texttt{SUB}$_{\mathtt{abs}}$.
\item Lines 14-16 check the value of $\delta = \{0,1\}$ based on the nonsensicality
  of the remainder, and adjust the quotient and remainder accordingly.
\end{enumerate}

\begin{figure}
\begin{lstlisting}[language=pseudo,escapeinside={!}{!}]
fun DIV u v =
  -- 1. Find a !\green$h$! and !\green$k$! that satisfies !\green$u \leq B^{h}$! and !$\green B^{k}\leq v < B^{k+1}$!
  h = FINDH u
  k = FINDK v
  -- 2. Enforce assumption !\green$k \neq 1$! of SHINV by shifting
  if k == 1 then u = shift 1 u
                 v = shift 1 v
                 h += 1
                 k += 1
  -- 3. Find quotient and remainder approximation according to Definition !{\hypersetup{allcolors=ForestGreen}\ref{def:quo}}!
  q = shift (-h) (MUL u (SHINV h k v))
  r = SUB!$_{\texttt{abs}}$! u (MUL q v)
  -- 4. Adjust the approximation for !\green$\delta$!
  if (r >= v) then q = ADD q 1
                   r = SUB!$_{\texttt{abs}}$! r v
  return (q, r)

-- finds !\green$k$! s.t. !$\green \texttt{B}^{\texttt{k}} \leq \texttt{v} < \texttt{B}^{\texttt{k}+\texttt{1}}$!
fun FINDK v =
  k = (sizeof v) - 1
  while v[k] == 0 do
    k -= 1
  return k

-- finds !\green$h$! s.t. !$\green u \leq B^{h}$! (by picking the smallest !\green$h$!)
fun FINDH u =
  h = FINDK u
  if u[h] == 1
  then return u
  else return u + 1
\end{lstlisting}
  \caption{\footnotesize Pseudocode for a big integer division algorithm, computing $u~\mathtt{quo}~v$ and $u~ \mathtt{rem}~ v$ using Definition \ref{def:quo} and function \texttt{SHINV} of Figure \ref{shinv}, where \texttt{MUL} is a big integer multiplication method, \texttt{SUB}$_{\mathtt{abs}}$ a absolute subtraction method, and \texttt{ADD} an addition method.}
  \label{div}
\end{figure}

\bigskip

Thus, the function \texttt{DIV} defined in Figure \ref{div} gives us an exact
division operator for big integers. It relies on the function \texttt{SHINV} of
Figures \ref{shinv} and \ref{shinvcont} (sub-functions thereof), and on
arithmetic operators for addition, subtraction, and multiplication of big
integers (such as \textit{badd}, \textit{bsub}, and \textit{convmul}), which, it
can be parameterized over. Hence, it is possible to e.g.\ use different
operators for different input sizes.

The division is asymptotically dominated by the choice of multiplication operator (given
that the addition and subtraction is efficiently implemented). The iterative
refinement process takes $\lceil \log (h-k) \rceil$ iterations, where $h$ depends on the
precision of the dividend and $k$ on the precision of the divisor. This number
comes from the fact that the refinement method produces a shifted inverse of
$h-k$ digits (as discussed in \ref{subsubsec:divalg1}), and it roughly doubles
the number of correct digits in the approximation at each iteration.

Each iteration step runs at most two multiplications (one in \texttt{STEP} and
either one or zero in \texttt{POWDIFF}). While this gives us at most
$2 \cdot \lceil \log (h-k) \rceil$ multiplications, the size of the inputs to the
multiplications is doubling at each iteration, due to the shorter iterates
method. From the analysis by Watt in \cite{watt2023efficient}, the total amount
of digits multiplied from this method, gives us $O(M(m))$ work, where $M(m)$ is
the work of the chosen multiplication operator and $m$ is the size of the input
integers for the division.

\pagebreak

\subsection{General Reflections and Prototyping}
\label{subsec:divproto}

This section discusses some concerns and solutions about the presented
algorithm. We wrote a sequential low-level prototype of the algorithm in C to
better understand its adaptation of our big integer representation. In its
creation, we discovered multiple interesting subject matters -- some which are
directly included in the pseudocode given in section \ref{subsec:divalg}, and
some which we now present.

\paragraph{Initial Approximation}
The initial approximation is found in step II of Listing \ref{shinv}. It gathers
the three leading digits of $v$ in $V$ and then finds $B^4-V$, giving a result
of four digits. It then divides those four digits by $V$, giving a result of
either one or two digits. Hence, the quadruple base type \texttt{qint\_t} is
necessary to efficiently compute the initial approximation with register
arithmetic. This restricts a CUDA implementation to base \texttt{uint32\_t} and
Futhark to \texttt{u16}. In C, this process corresponds to Listing \ref{initC}:
\begin{lstlisting}[language=CPP,caption={\footnotesize C code to efficiently form the initial approximation of \texttt{SHINV} in base \texttt{uint\_t} of \texttt{bits} bits and quad type \texttt{quint\_t} of $4\cdot$\texttt{bits} bits.},label={initC},escapeinside={!}{!}]
quint_t V = (quint_t) v[k-2];                        // V  = v[k-2]
V +=       ((quint_t) v[k-1]) << bits;               // V += v[k-1] !$\green\cdot$! B!$\green ^{\texttt{1}}$!
V +=       ((quint_t) v[k])   << (2*bits);           // V += v[k]   !$\green\cdot$! B!$\green ^{\texttt{2}}$!

quint_t r = (((quint_t) 0) - V) / V + ((quint_t) 1); // r = (B!$\green ^\texttt{4}$!!$\,\,\,$!-!$\,\,\,$!V)!$\,\,\,$!/!$\,\,\,$!V!$\,\,\,$!+!$\,\,\,$!1

w[0] = (uint_t) r;                                   // w = r 
w[1] = (uint_t) (r >> bits);                         // (assuming w was 0)
\end{lstlisting}

\paragraph{Base Powers}
These are prominent throughout the algorithm, and comes in a multitude of
usecases. When multiplied, they take the shape of a \texttt{shift} operator, as
already incorporated into the pseudocode. In the \texttt{POWDIFF} function, they
are returned or otherwise used directly, and hence, require construction in a
new memory space.

Remaining is the special cases of step I in the \texttt{SHINV} function. The
base powers are operands to comparisons that express something structural about
the divisor $v$. Hence, they can be integrated in said comparisons, avoiding
their construction.  E.g.\ consider the second case $v > B^h$. This optimizes to
the check: $\exists i\in \mathbb{N}.~(h<i<m \land v[i] \neq 0) \lor (h = i<m \land v[i] > 1)$.

(On a similar note, the multiplication by single precision of the third special
case $2v > B^h$ should be treated as $v > B^h/2$ and integrated in the
comparison as well.)

\paragraph{Preallocating Memory}
Throughout this thesis, the big integer arithmetic has been considered to preserve
the input shape on output. The efficiency of this algorithm requires fine control
over the size of operands at each iteration, and hence, we need to adjust the
size parameter of inputs and outputs, according to the iteration
number. Furthermore, it is ideal to preallocate a memory region large enough to
hold the biggest intermediate value of the refinement, rather than periodically
doubling the memory regions of the operands. From the analysis in Watt's paper
\cite{watt2023efficient}, the size of the operands at iteration $i$ is at most
$2^i$. Since we have $\lceil \log (h-k) \rceil$ iterations, we get the maximum operand
size $2^{\lceil \log (h-k) \rceil}$.

\paragraph{Guard Digits}
In order to get our prototype to validate, we adjusted the amount of guard
digits in the refinement method from $2$ to $m$, with $m$ being the size of the
inputs. Currently, we are not aware whether this is related to the algorithm or
an error in the prototype.

\subsection{Parallelization and Futhark Implementation}
\label{subsec:divfut}

While section \ref{subsec:divproto} focused on general reflections, this section
focuses on concerns and solutions regarding parallelization and Futhark
implementation. Our implementation is not efficient and only partially
validates, but it illustrates some of the complexities involved in a parallel
adaptation of the algorithm -- which we now present.

\paragraph{Multiple Instances per Block and Load Balancing}
In our other arithmetic operators, we incorporate multiple big integer instances
per CUDA block, which are then handled by segmented operations. It allows to
maintain the efficiency of the arithmetics when processing small
integers. However, Watt's algorithm for computing \texttt{SHINV} (Figure
\ref{shinv}) contains branching invariant to the precision of the inputs. The
most apparent branching is the special cases of \texttt{SHINV}, directly
returning from the function. Then we have the close product optimization in
\texttt{POWDIFF}, which will either do no multiplication, a full size
multiplication, or a multiplication with truncated inputs. Lastly, the number of
sequential Newton iterations in the refinement process directly depends on the
precision of the inputs.  Hence, the division algorithm is not suitable to
process multiple instances per block.

Furthermore, due to the shorter iterates, the number of digits being multiplied
at each refinement step roughly doubles. In turn, mapping this division at
block-level must be carefully considered. The simplest solution is to run all
operations in full-sized inputs -- however, as Watt analyze for the method he
calls \texttt{refine1} in \cite{watt2023efficient} (a method without shorter
iterates), this solution increases the work by a factor logarithmic in the
precision of its inputs. Another solution is to spawn a kernel with the exact
number of threads needed to efficiently run the arithmetic of greatest input
length. However, this results in threads idling for arithmetics of shorter
length. Likewise, if the kernel spawns with an inadequate number of threads, the
sequentialization factor of the arithmetic of the greatest length input may
exhaust registers and local memory, overall decreasing efficiency.\footnote{The
  current Futhark implementation (and C prototype) runs the arithmetics at
  padded full-size length.}

\bigskip

\paragraph{Shift Operator}
Shifting a big integer in parallel is very efficient and equivalent to a map, as
seen on the Futhark code in Listing \ref{shiftfut}. We can transform the
operator to be in-place in CUDA by splitting the map: Fetch the designated digit
$\shortrightarrow$ synchronize $\shortrightarrow$ write the digit.
\begin{lstlisting}[language=futhark,caption={\footnotesize Shift operator (Definition \ref{def:shifts}) in Futhark from file \texttt{helper.fut}.},firstnumber=96,label={shiftfut}]
def shift [m] (n: i64) (u: [m]ui) : [m]ui =
  map (\ i -> let off = i - n -- positive for right, negative for left
              in if off >= 0 && off < m then u[off] else 0) (iota m)
\end{lstlisting}

\paragraph{Division by Single Precision}
The first special case of \texttt{SHINV} where $v<B$ requires quotient by a
single precision integer (digit). The intuition follows from Definition
\ref{def:bigints} and states that the quotient of a size $m$ integer $u$ by
digit $d$ in base $B$ can be computed as:
\begin{equation}
  \label{eq:divsing}
  q_i = \dfrac{\sum_{j=i}^{m-1} u_j \cdot B^{j-i}}{d}~ \mathtt{rem}~ B
\end{equation}
E.g.\ consider the decimal number 300 divided by 4: We have
$q_0 = (300 / 4)~ \mathtt{rem}~ 10 = 5$, $q_1 = (30 / 4)~ \mathtt{rem}~ 10 = 7$
and $q_2 = (3 / 4)~\mathtt{rem}~10 = 0$, giving the number 75. This approach
includes the big integer $u$ and does not fit in a word. However, Equation
\ref{eq:divsing} can be rephrased in terms of the standard long division
(grade-school) method. The method formalizes to computing the partial quotient
$q_{i\in\{0,..,m-1\}}$ using the partial remainder $r_{i\in\{0,..,m\}}$ as follows:
\begin{align}
  q_i &= \left( r_{i+1} \cdot B + u_i\right)~ \mathtt{quo}~ d\\
  r_i &= \begin{cases} \left( r_{i+1} \cdot B + u_i\right)~ \mathtt{rem}~d & \text{if}~i<m \\ 0 & \text{otherwise} \end{cases}
\end{align}
The intermediate results of this approach fits in a double word. This algorithm
is a simple solution (opposed to e.g.\ GMP's) and the one occupying our
sequential prototype. However, it is inherently right-to-left
sequential and unsuitable for parallel computation.

We recognise three approaches:
\begin{enumerate}
\item Parallelize the long division algorithm (possibly over a scan similarly to
  addition).\label{divbysing1}
\item Computing an inverse (e.g.\ a whole shifted inverse by a method similar to
  \texttt{SHINV}), but this approach requires a multiplication
  afterwards.\label{divbysing2}
\item Shifting both $u$ and $v$ by two when $k = 0$ (similarly to the shift by
  one when $k=1$).\label{divbysing3}
\end{enumerate}

The potentialities of approach \ref{divbysing1} and \ref{divbysing2} are unknown
to us and beyond the scope of this thesis. Hence, we use approach
\ref{divbysing3} for our parallel Futhark implementation.

\paragraph{Assumptions, Comparisons, and Signed Subtraction}
The algorithm has various comparisons of big integers, all of which
parallelizes to map-reduce compositions. First, consider the special cases of
\texttt{SHINV}. As mentioned in section \ref{subsec:divproto}, they can be
optimized to a unary comparison over the big integer. Following the example of
that section, the second special case $v > B^h$ parallelizes to Listing
\ref{gtbpow}:
\begin{lstlisting}[language=futhark,caption={\footnotesize Futhark function to check $u > B^i$ in parallel for big integer $u$ in base $B$ from file \texttt{div.fut}.},label={gtbpow},firstnumber=29]
def gtBpow [m] (u: [m]ui) (i: i64) : bool =
  map2 (\ x j -> (x > 1 && j == i) || (x > 0 && j > i) ) u (iota m)
  |> reduce (||) false
\end{lstlisting}
Next, we have the equalities involved with the \texttt{POWDIFF}
function. Equality of big integers corresponds to equality between digits, which
parallelizes straightforward. Then there are the structural assumptions of big
integers, written sequentially as the helpers \texttt{FINDK}, \texttt{FINDH},
and \texttt{PREC} of Figures \ref{shinvcont} and \ref{div}. They parallelize to a map-reduce
composition that finds the greatest nonzero index. E.g.\ Listing \ref{findk}
shows a parallel \texttt{FINDK}, where the map-reduce is equivalent to the
\textit{max} function over the indices of nonzero digits in the input:
\begin{lstlisting}[language=futhark,caption={\footnotesize Futhark function to find $i$ for big integer $u$ in base $B$ s.t.\ $B^i \leq u < B^{i+1}$ from file \texttt{div.fut}.},label={findk},firstnumber=39]
def findk [m] (u: [m]ui) : i64 =
  map2 (\ x i -> if x != 0 then i else 0 ) u (iota m)
  |> reduce (\ acc i -> if i != 0 then i else acc ) 0
\end{lstlisting}

Penultimately, the subtraction presented in section \ref{subsec:sub} is
unsigned, yet \texttt{POWDIFF} requires signed subtraction. Extending the
subtraction to signs is trivial, achieved by determining the relation between
the operands. For this purpose, we use the general big integer `$<$` comparison
of Listing \ref{lt}. The map in line 84 encodes whether the pairwise digits of
the inputs are either `$<$` or `$=$`. Line 85 then reduce with the following
operator:
\begin{equation}
  \label{eq:lt}
  \tup{\mathit{l1}}{\mathit{e1}} \odot \tup{\mathit{l2}}{\mathit{e2}} \coloneq \tup{\mathit{l2} \lor (\mathit{e2} \land \mathit{l1})}{\mathit{e1} \land \mathit{e2}}
\end{equation}
The rationale is: If the first operand is less than the second operand in the
most significant digits, then the whole integer is less than -- if it is equal in
the most significant digits, then it is decided in the least significant
digits. The left-associative neutral element of $\odot$ is
$\tup{\mathtt{False}}{\mathtt{True}}$. Proof of associativity and neutral
element are included in Appendix \hyperref[app:C]{C}.

\begin{lstlisting}[language=futhark,caption={\footnotesize Futhark function to check $u < v$ in parallel for big integers $u$ and $v$ from file \texttt{helper.fut}.},label={lt},firstnumber=83]
def lt [m] (u: [m]ui) (v: [m]ui) : bool =
  map2 (\ x y -> (x < y, x == y) ) u v
  |> reduce (\(l1,e1) (l2,e2) -> (l2 || (e2 && l1), e1 && e2)) (false,true)
  |> fst -- `fst` extracts the first tuple field
\end{lstlisting}

Lastly, we have the `$\geq$` associated with finding $\delta$ (line 14 of Listing
\ref{div}). This can be done efficiently by negating the result of the `$<$`
operator of Listing \ref{lt} above.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
