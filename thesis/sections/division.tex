\section{Division}
\label{sec:div}

The last of the basic arithmetics is division. It is far more complicated than
the others and intrinsically in conflict with our domain. We say the division is
\textit{exact} when the divisor precisely divides the dividend. When the
division is not exact, the result is ordinarily represented by a fraction -- yet
we do not desire to leave the domain of integers. Instead, we use the notion of
\textit{quotient} and \textit{remainder} commonly present in integer semantics:
\begin{align}
  u~\mathtt{quo}~v &\coloneq \lfloor u/v \rfloor\\
  u~ \mathtt{rem}~v &\coloneq u - \left( u~\mathtt{quo}~v \right)\cdot v
\end{align}
Usually, the quotient is associated with the division operator and the remainder
with the modulus operator. Our division computes both values and return them as
a pair.

A common way to reason about division is to multiply the dividend with the
inverse of the divisor, also called the reciprocal. GMP use reciprocals for
division by single precision, but since reciprocals are expensive to compute,
their base case division use Knuth's algorithm for long division, also known as
\textit{grade-school} division \cite{GMP, knuth97}. This algorithm is inherently
sequential: It iteratively produce the result by finding one correct digit per
iteration, and thus, unfit for GPGPU. As a result, we focus on algorithms using
the inverse of the divisor.

A well known algorithm to find reciprocals is the Newton-Raphson method. It
takes an initial approximation, and through a series of iterative steps (also
called Newton iterations), refines the precision of the approximation. While it
too performs a number of inherently sequential iterations, the precision of the
approximation roughly doubles at each iteration, making it more suitable for
GPGPU than long division.

However, it presents a new hurdle w.r.t.\ the internal representation of both
the inverse and the intermediate approximations in iteration steps. One solution
is to use fractions internally and convert back to integers before returning the
output. The downsides to this solution is the potential loss of precision when
using floating points (i.e.\ it will no longer be an exact arithmetic) and the
overhead of converting between representations.

Instead, we use Watt's efficient and exact arithmetic algorithm for computing
quotients, presented in \cite{watt2023efficient}. The prerequisite of the
algorithm is the existence of a shift operation for the chosen data type -- which
is a efficient operation for integers -- and a multiplication method given as a
argument. The intuition is to utilize the shift operation in order to avoid the
domain change associated with computing the inverse, by instead computing what
is referred to as the \textit{whole shifted inverse}.

This section is structured as follows: In \ref{subsec:divalg} we give a detailed
introduction to the algorithm formulated by Watt in \cite{watt2023efficient}. We
also present some revisions to the algorithm -- notably an unconsidered corner
case -- and reflect on its adaptability to the domain of big integers. In
\ref{subsec:divproto} we show a sequential prototype of the algorithm written in
C. It serves to fully understand the complexities involved in adapting the
algorithm to big integers. Lastly, in \ref{subsec:divfut} we demonstrate how to
parallelize the algorithm using Futhark, based on the methods we discovered
during the prototyping.

\subsection{Algorithm}
\label{subsec:divalg}

Before discussing the exact division algorithm, we introduce a new notation: The
\textit{precision} of a big integer (denoted by $p$) refers to the number of
digits without leading zeroes. E.g.\ the integer $\arr{1,2,0}$ has size $m=3$
and precision $p=2$.

We will now give the intuition behind the algorithm defined by Watt in his paper
\cite{watt2023efficient}, and refer to his paper for the proofs and the generic
version. The foundation of the algorithm is a whole shift operator and a whole
shifted inverse operator:

\begin{definition}[whole shift and whole shifted inverse of big integers]
  We define a $n \in \mathbb{Z}$ whole shift and $n' \in \mathbb{N}$ whole shifted inverse of big
  integers $u\in \mathbb{N}$ and $v\in \mathbb{N}^{+}$ in base $B$ as:
  \begin{equation}\label{eq:shifts}
    \mathtt{shift}_n~u \coloneq \lfloor u \cdot B^n \rfloor \quad \qquad \mathtt{shinv}_{n'}~v \coloneq \lfloor B^{n'}/ v \rfloor
    \end{equation}
\end{definition}

A shift in our array-oriented representation behaves similarly to a binary
system arithmetic shift, e.g.\ $\mathtt{shift}_1~\arr{1,2,3} = \arr{0,1,2}$ and
$\mathtt{shift}_{-1}~\arr{1,2,3} = \arr{2,3,0}$. The shifted inverse has a more
abstract interpretation -- given some $n'>p$ it essentially behaves as a
fractional inverse that is then "shifted into our domain". Consider the
following example:

\begin{example}
Suppose we have the integer $u=\arr{1,2,3}$ in base $B=2^{32}$ and wish to divide
it by the integer $v=\arr{1,1,0}$ in base $B$. Since $v$ is of precision $p=2$,
we get a proper inverse representation of $v$ by computing the $n$ shifted
inverse for some $n>p$. We pick $n=3$:
\begin{equation}
\label{eq:3}
\mathtt{shinv}_3~\arr{1,1,0} = \arr{0,4294967295,0}
\end{equation}
We can then multiply $u$ with the shifted inverse (expanding the result size),
and gets:
\begin{equation}
  \label{eq:4}
  \arr{1,2,3}\cdot\arr{0,4294967295,0} = \arr{0,4294967295,4294967294,4294967294,2}
\end{equation}
Now, since the fractional part of the inverse was "shifted into our domain" by
3, the result of this multiplication is also shifted by 3 (from associativity of
multiplication). Hence we shift it by $-3$ (and compress it to the original
size):
\begin{equation}
  \label{eq:5}
  \mathtt{shift}_{-3}~\arr{0,4294967295,4294967294,4294967294,2} = \arr{4294967294,2,0}
\end{equation}
The correct answer is $\arr{4294967295,2,0}$, so the method is off by $1$. This
is an accommodated byproduct of computing the whole shifted inverse. However,
the method approximates the result by an difference of at most $1$, allowing us
to mechanically adjust the result.\newline
\end{example}

The formal definition given by Watt in Theorem 1 of his paper
\cite{watt2023efficient} is as follows:

\begin{definition}[quotient of big integers by whole shifted inverse]\label{def:quo}
  For the base $B$ big integers $u$ and $v$ and some $h\in \mathbb{N}$ s.t.\
  $u \leq B^h$, the quotient of $u$ by $v$ is:
  \begin{equation}
    \label{eq:defquo}
    u~\mathtt{quo}~v = \mathtt{shift}_{-h}~ (u \cdot \mathtt{shinv}_h~v) + \delta,\quad \text{where~} \delta \in \{0,1\}
  \end{equation}
\end{definition}

The challenge now lies in computing \texttt{shinv}. Watt's algorithm use a
Newton iteration over integers and specialized to the base in order to use
shifts rather than fractions. The algorithm can roughly be divided into three
steps:
\begin{enumerate}[label=\Roman*]
\item Handle the special (and easy) cases, namely when $v \leq B$ or $v > B^h/2$.\label{shinvI}
\item Find an initial approximation that guarantees the Newton iterations
  converges fast.\label{shinvII}
\item Refine the initial approximation iteratively until it is sufficient.\label{shinvIII}
\end{enumerate}
Listing \ref{shinv} below shows the pseudocode for this operation. In step
\ref{shinvI} we have four special cases. They serves dual purposes: To guarantee
that $B < v \leq B^h/2$ (an assumption of the initial approximation for fast
convergence) and to be faster. The first case is when $v$ only consists of a
single digit, and we use a division by single precision method.\footnote{As
  mentioned earlier in how GMP handle division, this case can generally be
  handled more efficient.} The next two cases is if $v > u$ or $2v > u$ and so
the inverse is $0$ and $1$, respectively. The last case is when $v$ is exactly a
power of its base, and we can use the rule $x^a/x^b=x^{a-b}$ instead.

Step \ref{shinvII} computes the initial approximation using the last three
digits of $v$, e.g.\ for $v$ of size $m$ we get $V= \arr{v[m-3],v[m-2],v[m-1]}$.
However, this is where we introduce our revision: Computing $V$ in this manner
requires $v \geq B^2$, which is not guaranteed by the special cases. This function
instead assumes that the precision of $v$ is not 2, i.e.
$B^k\leq v < B^{k+1} \land k \neq 1$. We show how to enforce this assumption when
presenting Listing \ref{div}, and shortly see why the assumption is important.

Hence, the initial approximation of $w$ (line 9) always consists of two leading
correct digits. Step \ref{shinvIII} checks whether the shifted inverse consists
of one or two digits, and return the approximation accordingly. If it needs more
digits of precision, it starts the refinement process using the specialized
Newton iteration. Watt presents three refinement methods with a varying degree
of optimizations. The method we use is the optimal (\texttt{refine3} of
Algorithm 1 in \cite{watt2023efficient}), which we describe shortly when
presenting Listing \ref{refine}. However, it use something called
\textit{shorter iterates} which has the side effect of each iteration being one
digit short of doubling the precision. This means that the number of correct
leading digits, from now on referred to as $l$, must be $\geq 2$. Thus, we if
$k = 1$ and we are in the case where $h-k>2$, then we would start refining on
$l=1$, and so one digit short of doubling $l=1$ is $l=1$, and hence, the
refinement never increases the precision and runs forever.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing \texttt{shinv}$_h~v$ in base $B$, where $B^k \leq v < B^{k+1}, k\neq 1$, \texttt{quo}$_{\mathtt{digit}}$ and \texttt{*}$_{\mathtt{digit}}$ are quotient and multiplication by single precision, and \texttt{REFINE} is an approximation refinement method.},label={shinv}]
fun SHINV h k v =
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvI}}! Special cases
  if v          <  B!$^{\phantom{\texttt{h}}}$! then return B!$^\mathtt{h}$! quo!$_{\texttt{digit}}$! v[0]
  if v          >  B!$^\texttt{h}$! then return 0
  if (v *!$_{\texttt{digit}}$! 2) >  B!$^\texttt{h}$! then return 1
  if v          == B!$^\mathtt{k}$! then return B!$^{\texttt{h}-\texttt{k}}$!
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvII}}! Initial approximation
  V = v[k-2] + (v[k-1] * B) + (v[k] * B!$^{\texttt{2}}$!)
  w = (B!$^{\texttt{4}}$! - V) / V + 1
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvIII}}! Refine until sufficient
  if h - k <= 2 then return shift (h - k - 2) w 
  return REFINE v w h k 2
\end{lstlisting}

We will now present how to compute Definition \ref{def:quo} using \texttt{SHINV}
and how to enforce the assumption $k\neq 1$ using shifts. The Pseudocode is in
Listing \ref{div} and contains four steps. Step 1.\ (lines 3-4) computes the
assumptions straightforward using helpers from Figure \ref{divhelpers}. Step
2.\ handles the case $k=1$ by shifting both $u$ and $v$ by one. Note, a $n$-shift
is equivalent to multiplying by $B^n$, so the quotient is
unaffected. Furthermore, the relation between $h$ and $k$ remains the same, so
we do not introduce further iterations inside \texttt{SHINV}. Step 3.\ computes
the quotient and remainder from Equation (\ref{eq:defquo}) straightforward with
$\delta=0$, using some multiplication method \texttt{MUL} and absolute subtraction
method \texttt{SUB}$_{\mathtt{abs}}$. Lastly, step 4.\ finds $\delta$ and adjusts the
result accordingly, by checking whether the remainder is nonsensical.

\begin{figure}
{
\hrule\vspace*{-0.4ex}
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=pseudo,frame=,escapeinside={!}{!}]
-- finds `k` s.t. !$\green \texttt{B}^{\texttt{k}} \leq \texttt{v} < \texttt{B}^{\texttt{k}+\texttt{1}}$!
fun FINDK v =
  k = (sizeof v) - 1
  while v[k] == 0 do
    k -= 1
  return k

-- finds `p` s.t. !$\green \texttt{v} < \texttt{B}^{\texttt{p}}$!
fun PREC v =
  return FUNDK v + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=pseudo,firstnumber=11,frame=,escapeinside={!}{!}]
-- finds `h` s.t. !$\green \texttt{u} \leq \texttt{B}^{\texttt{h}}$!
fun FINDH u =
  h = FINDK u
  if u[h] == 1
  then return u
  else return u + 1

-- computes !$\green ( \texttt{v}\cdot \texttt{w})~\texttt{rem}~\texttt{B}^{\texttt{L}}$!
fun MULMOD v w L =
  return take L (MUL v w)
\end{lstlisting}
\end{minipage}\vspace*{-0.8ex}
\hrule
}
\caption{\footnotesize Helpers for Watt's division algorithm, where MUL is some given multiplication method.}
\label{divhelpers}
\end{figure}

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing $u~\mathtt{quo}~v$ and $u~ \mathtt{rem}~ v$ using Definition \ref{def:quo}, where \texttt{MUL} is some big int multiplication method, \texttt{SUB} subtraction method, \texttt{ADD} addition method, and with helpers from Listing \ref{divhelpers}.},label={div}]
fun DIV u v =
  -- 1. Find assumptions
  h = FINDH u
  k = FINDK v
  -- 2. Avoid non-terminating loop
  if k == 1 then u = shift 1 u
                 v = shift 1 v
                 h += 1
                 k += 1
  -- 3. Find quotient and remainder
  q = shift (-h) (MUL u (SHINV h k v))
  r = SUB!$_{\texttt{abs}}$! u (MUL q v)
  -- 4. Adjust for !\green$\delta$!
  if (r >= v) then q = ADD q 1
                   r = SUB r v
  return (q, r)
\end{lstlisting}

Next, we present the refinement method used by \texttt{SHINV}. The pseudocode is
in Listing \ref{refine} and contains no alterations to the original formulation
in \cite{watt2023efficient}. It use the method \texttt{STEP} to compute a Newton
iteration, which we shortly discuss when presenting Listing \ref{step}. This
method expands the specialized Newton iteration with two concepts;
\textit{shorter iterates} and \textit{divisor prefixes}. Shorter iterates is the
idea that not all digits of the intermediate results between iterations
matters. Since the precision roughly doubles, only the leading $l$ digits of the
intermediate results contributes to the refinement at each iteration. Line 5
computes the number of leading digits relevant for the current iteration. It
effectively allows us to truncate the size of of the big integers in the
\texttt{STEP} function, rather than doing each step in full size, s.t.\ the size
of the integers in each Newton step roughly doubles at each iteration.

In turn, this introduces the need for \textit{guard digits} because the
truncated sized steps may differ from the full sized steps, but only in the two
least significant digits. Hence, we use $2$ guard digits as defined in line 2,
and shift the approximate $w$ accordingly.

Lastly, the divisor prefixes is the idea that when the divisor $v$ is large
relative to shifted inverse approximated at each iteration, some of the leading
digits of $v$ does not contribute to the result of the iteration step. Instead,
we use a prefix of $v$ to further truncate the size of the big integers at each
step. This process too is imprecise, but it is defined such that it is accounted
for by the 2 guard digits. The scaling of $v$ is determined in line 6.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for refining the shifted inverse approximation $w$ of $l$ correct leading digits using the Newton iterate step function \texttt{STEP} of Listing \ref{step}, where the computational work of finding iterates is reduced by using shorter iterates and divisor prefixes.},label={refine}]
fun REFINE v w h k l =
  g = 2          -- guard digits to account for shorter
  w = shift g w  -- iterate and divisor prefix inexactness
  while h - k > l do
    n = min l (h - k + 1 - l)   -- `n` is amount to grow the iterate
    s = max 0 (k - 2*l + 1 - g) -- `s` is amount to scale `v` with
    w = shift (-1) (STEP (k + l + n - s + g) (shift (-s) v) w n l g)
    l += n - 1                  -- `l` is amount of correct leading digits
  return shift (-g) w
\end{lstlisting}

Next up is the Newton step function \texttt{STEP}. Its pseudocode is in Listing
\ref{step}. This is where most of the computational work lies since it contains
two multiplications. The function computes
$\mathit{step}(h,v,w,n) = w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$ as
given by Watt in \cite{watt2023efficient}. From the calling procedure of
\texttt{STEP} in \texttt{REFINE}, we get that the function corresponds to
$w\cdot B^l + \lfloor w \cdot (B^{l} - B^{-k+s-g} \cdot \lfloor v\cdot B^{-s} \rfloor \cdot w)\rfloor$, which satisfies the
properties of divisor prefix and shorter iterates proofed by Watt. We have made
no alterations to the original function formulation, except for explicitly
handling the sign and magnitude of the \texttt{POWDIFF} function.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing a Newton step of the refinement method in Listing \ref{refine} for big ints $v$ and $w$ defined as $\mathit{step}(h,v,w,n) = w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$. $h$ is the parameter and $n$ the number of more digits to correctly refine in this step. $l$ is the number of leading digits currently correct and $g$ is the amount of guard digits added by the refinement method -- which are both passed down to and enables optimizations in the function \texttt{POWDIFF} given in Listing \ref{powdiff} that computes $B^{h-n}-v\cdot w$. \texttt{MUL} is some big int multiplication method, \texttt{SUB}$_{\mathtt{abs}}$ is absolute subtraction for big ints, and \texttt{ADD} is addition for big ints.},label={step}]
fun STEP h v w n l g =
  -- 1. Compute !$\green \texttt{B}^{\texttt{h}- \texttt{n}}- \texttt{v} \cdot \texttt{w}$!
  (pwd, sign) = POWDIFF v w (h-n) (l-g)
  -- 2. Compute and return !$\green\texttt{w} \cdot \texttt{B}^{\texttt{n} - \texttt{h}}+ \lfloor \texttt{w} \cdot ( \texttt{B}^{\texttt{h}}- \texttt{v}\cdot \texttt{w})\cdot \texttt{B}^{\texttt{2n} - \texttt{h}}\rfloor$!
  if sign
  then return SUB!$_{\texttt{abs}}$! (shift n w) (shift (2*n - h) (MUL w pwd))
  else return ADD!$_{\phantom{\texttt{abs}}}$! (shift n w) (shift (2*n - h) (MUL w pwd))
\end{lstlisting}

Lastly is the function \texttt{POWDIFF}. The term $B^h-v \cdot w$ appears in each
iteration step. While it can be computed straightforward, Watt increases the
efficiency by using close products. The idea is that in cases where the product
$v\cdot w$ is close to $B^h$ by a factor of $|B^h- v\cdot w|\leq B^L, L < h$, only the
lower $L$ digits of the product $v \cdot w$ is needed. Hence, we can use a truncated
multiplication of size $L$ rather than the size of $v$ and $w$. Listing
\ref{powdiff} shows the pseudocode for this function:
\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode computing $\mathit{powdiff(v,w,h)}=B^{h}- v \cdot w$ efficiently using close products and helpers from Listing \ref{divhelpers}, where $l$ is number of correct leading digits in $w$, \texttt{MUL} is a big int multiplication method, and \texttt{SUB} is signed big int subtraction, with \texttt{false} indicating unsigned and \texttt{true} signed.},label={powdiff}]
fun POWDIFF v w h l =
  L = (PREC v) + (PREC w) - l + 1
  -- Constant case where !$\green\texttt{v}\cdot \texttt{w} = \texttt{0}$!, so result is B!$^{\green\texttt{h}}$!
  if (v == 0) || (w == 0) then return (B!$^{\texttt{h}}$!, false)
  -- Worst case where the multiplication !$\green\texttt{v}\cdot \texttt{w}$! is in full size
  if L >= h               then return SUB B!$^{\texttt{h}}$! (MUL v w)
  -- Close product case where only the lower L digits of !$\green\texttt{v}\cdot \texttt{w}$! is needed
  P = MULMOD v w L
  if P      == 0 then return (P, false)
  if P[L-1] == 0 then return (P, true)
  return SUB B!$^{\texttt{L}}$! P
\end{lstlisting}

Thus, by using our defined \texttt{DIV}, the revised \texttt{SHINV}, and the big
integer specialized \texttt{REFINE}, \texttt{STEP}, \texttt{POWDIFF} and helper
functions, we achieve an exact division operator for big integers. It relies on
arithmetic operators for addition, subtraction, and multiplication of big
integers (such as \textit{badd}, \textit{bsub}, and \textit{convmul}), but is
independent from the implementation of said operators. Hence, it is possible to
e.g.\ use different operators for different input sizes. The asymptotics is
dominated by the choice of multiplication operator (given that the addition and
subtraction is efficiently implemented). The iterative refinement process takes
$\lceil \log (h-k) \rceil$ iterations, and each iteration step runs two
multiplications. Due to the structure and optimizations of the refinement
process, the work is $O(M(m))$, where $M(m)$ is the work of the chosen
multiplication operator and $m$ is the size of the input integers.




\subsection{Overall Thoughts and Prototype}
\label{subsec:divproto}
{\red [TODO; rewrite]}

We started by writing a prototype of the algorithm in C to better understand the
inner workings of the algorithm. In its creation, we discovered some
optimization with respect to our big integer data structure. Here are some
notable subroutines and how we handle them.

\begin{itemize}[leftmargin=*]
\item \textbf{Base Powers}\\
  These are prominent throughout the algorithm, and comes in a multitude of
  usecases. However, most of the time they express something structural about a
  big integer, and hence, can be optimized to a constant work check on the
  integer.

  E.g. consider the comparison $v > B^h$ for a big integer $v$ of precision $m$
  in base $B$. Instead of constructing $B^h$ and compare it to $v$, we can
  simply check whether any digits are index greater than $h$ are non-zero, the
  digit exactly at index $h$ is greater than $1$, or simply shortcircuit if
  $m < d$.
\item \textbf{Multmod}\\
  For big integers $u$ and $v$ in base $B$, we define
  $\fun{MultMod}(u,v,d) = (u \cdot v) \% (B^d)$. At first glance, this function
  requires to double the precision $m$ for the multiplication, and then run a
  computationally heavy modulus operation. However, taking the modulus of $B^d$
  corresponds to zeroing out the $m \log B - d$ upper bits of an integer.

  Thus, as these bits will not contribute to the result, $\fun{MultMod}$ is
  equivalent to a truncated multiplication. I.e. exact precision multiplication
  of precision $\fun{min}(d, m)$.

\item \textbf{Initial Approximation}\\
  The initial approximation is 4 digits divided by 2 digits and can be computed
  efficiently using register arithmetics, if we have access to registers of
  4$\times$ base size.

\item \textbf{PowDiff}\\
  This function computes the power difference of two big integers, their base
  and an exponent, defined $\fun{PowDiff}(u, v, h) = B^h - u \cdot v$. This function
  requires sign extension. However, instead of modifying our domain to signed
  big integers, we can simply return a boolean sign indicator - the sign will
  only dictate whether we add or subtract in the $\fun{Step}$-function, but the
  result will be unsigned regardless.

\item \textbf{Approximation Factor}\\
  Since the algorithm approximates the exact result by a factor of 1, i.e.
  $\delta = \{0,1\}$. We were not able to predict $\delta$, but it is trivially decidable
  by reversing the division with multiplication. This requires one extra
  multiplication, but is essentially free if we consider the remainder to be
  part of the algorithms output.
\end{itemize}

% \subsection{Single Precision Divisor}
% % In the prototype, a standard Long Division algorithm is used. Another way to
% % express the computation of long division is:
% % \begin{equation}
% %   \label{eq:1}
% %   q_i = \dfrac{\sum_{j=i}^{m-1} u_j \cdot B^{j-i}}{v}\% B
% % \end{equation}
% % E.g. consider the decimal number 500 divided by 4: We have
% % $q_0 = (500 / 4) \% 10 = 5$, $q_1 = (50 / 4) \% 10 = 2$ and
% % $q_2 = (5 / 4) \% 10 = 1$, i.e., the number 125.

% % We have the following rule for division and modulus:
% % \begin{equation}
% % \label{eq:2}
% % \frac{a}{b} \% c = () \% c
% % \end{equation}
% % \begin{equation}
% %   \label{eq:1}
% %   q_i = \dfrac{\sum_{j=i}^{m-1} \left( (u_j \% v)\cdot B^{j-i}\right) }{v}\% B
% % \end{equation}
% % \begin{equation}
% %   \label{eq:1}
% %   r_i = \left( \sum_{j=i}^{m-1} u_j \cdot B^{j-i} \right) \% v
% % \end{equation}

% % ~

% The quotient of size $m$ big integer $u$ and digit $d$ in base $B$ can be
% computed as:
% \begin{equation}
%   \label{eq:1}
%   q_i = \dfrac{\sum_{j=i}^{m-1} u_j \cdot B^{j-i}}{d}\% B
% \end{equation}
% E.g. consider the decimal number 500 divided by 4: We have
% $q_0 = (500 / 4) \% 10 = 5$, $q_1 = (50 / 4) \% 10 = 2$ and
% $q_2 = (5 / 4) \% 10 = 1$, i.e., the number 125. This approach does not fit a
% wordsize, as it includes the big integer $u$.

% In the sequential prototype, a standard Long Division algorithm is
% used\footnote{Since the divisor is single precision, it is called Short Division
%   instead of Long Division.}. The algorithm computes the partial quotient
% $q_{i\in\{0,..,m-1\}}$, using the partial remainder $r_{i\in\{0,..,m\}}$ as follows:
% \begin{equation}
%   \label{eq:1}
%   q_i = \left( r_{i+1} \cdot B + u_i\right) / d
% \end{equation}
% \begin{equation}
%   \label{eq:1}
%   r_i = \begin{cases} \left( r_{i+1} \cdot B + u_i\right) \% d & \text{if}~i<m \\ 0 & \text{otherwise} \end{cases}
% \end{equation}
% The intermideate results fits in a double word, and the algorithm is inherently
% sequential from left-to-right.

% From the definition of modulo, $a \% b = a - \lfloor \frac{a}{c} \rfloor \cdot b$,

\subsection{Parallelization and Futhark Implementation}
\label{subsec:divfut}

{\red [Missing]}




% As an example, lets handrun divison $\frac{u}{v}$ on the big integers $u = \texttt{[8,0,0,5]}$ and $v = \texttt{[4,2,0,0]}$ in base $B=2^{32}$. First, we must find $h$ such that $u\leq B^h$. A trivial pick is the precision of $u$ since the most significant digit is non-zero, i.e., $h=4$. Now comes the tricky part; we must find the whole shifted inverse of $v$ with respect to $h$, i.e., $\mathtt{shinv}_hv$.

% First we must find $k$ such that $B^k\leq v < B^{k+1}$. This is simply the precision - 1, so we have $k = 1$. Next we have the four special cases which guarantee that $B < v \leq \frac{B^h}{2}$. The first case is if $v < B$, or, if only the first digit of $v$ is set. The second case is if $v > B^h$, which means that $v>u$ and the division $\frac{u}{v}$ floors to $0$. The third case is if $2v > B^h$, which means that the division floors to $1$. The last case is if $v = B^k$, which means that $v$ is exactly a multiple of the base, and so the whole shifted inverse of $v$ is also a multiple of the base.

% In our example, we hit none of these special cases. Thus, we continue to compute a initial approximation of the whole shifted inverse. This approximation is computed by a division of a 4-digit big integer by a 2-digit big integer. Since we use base $B = 2^{32}$, we could do this in as one division in base $2^{128}$. However we chose to implement it, we get:
% \[l = \mathtt{min}(k,2) = \mathtt{min}(1,2) = 1\]
% \[V = \sum_{i=0}^lv_{k-l+i}B^i = 4 * B^0 + 2 * B^{1} = 8589934596\]
% \[w = (B^{2l}- V ) / (V + 1) = 18446744065119617020 / 8589934597 = 2147483645\]
% Hence, the initial approximation is the big integer $w = \mathtt{[2147483645,0,0,0]}$.

% We then check if this approximation is sufficient by the condition $h-k \leq l$, or in our case, $3 \leq 1$, which is clearly false. Since it is not a sufficient, we start refining. Let us consider \texttt{refine3} as the refine method, since this is the best proposed method.

% In this method, we have 2 guard digits, i.e:
% \[g = 2\]
% \[w = \mathtt{shift}_2w = \mathtt{[0,0,2147483645,0]}\]
% We then start the iterative refinement. This lasts until the sufficiency-condition above becomes true. We can see $l$ as the number of digits that are correctly approximated and $h - k$ as the total number of digits to approximate. In each iteration, we first find how much to grow $w$ denoted $n$ and how to scale $w$ in the iteration denoted $s$. In our case, we have:
% \[n = \mathtt{min}(h-k+1, l) = \mathtt{min}(2, 1) = 1\]
% \[s = \mathtt{max}(0, k - 2l + 1 - g) = \mathtt{max}(0,-2) = 0\]
% Now comes the meat of the iterations; we take a refinement \texttt{step}:
% \[ \mathtt{step}(k + l + n - s + g, \mathtt{shift}_{-s}v, w, n, l, g) = \mathtt{step}(3, 0, w, n, l, g)\]
% First we shift $w$ by the growth factor:
% \[w0 = \mathtt{shift}_nw = \mathtt{shift}_1 \mathtt{[0,0,2147483645,0]}= \mathtt{[0,0,0,2147483645]}\]

% Next up we compute the \texttt{powdiff} of $w$.
% \[w1 = \mathtt{powdiff}(v,w,h-n,l-g) = \mathtt{powdiff}(0,w,2,-1)\]
% This function computes $B^{h}-v\cdot w = B^{2}-0\cdot w = B^2$, but let us see how. First we find the difference between the number of approximated digits minus the guard digits and the precision after the multiplication plus 1:
% \[ L = \mathtt{prec}~v + \mathtt{prec}~w - l + 1 = 0 + 2 + 1 + 1 = 4\]
% Then, we check whether we can easily compute this, which we can if $w = 0 \lor v = 0 \lor L \geq h$, which is the case right now since $v = 0$ and also $L = 4 \geq 2 = h$. Hence, we return $B^{h}=B^{2}=18446744073709551616$.

% Now when we have the \texttt{powdiff}, we get our $w1$, which we then multiply by $w$:
% \[w1 = \mathtt{powdiff}(v,w,h-n,l-g) = 18446744073709551616\]
% \[w2 = w \times w1 = 730750817644604358339027025968017687532661637120\]
% As a big integer, we get $w2 = \mathtt{[0,0,0,0,2147483645]}$, which we now shift by $2n - h$:
% \[w3 = \mathtt{shift}_{2n - h}w2 = \mathtt{shift}_{2 - 3}w2 = \mathtt{shift}_{-1}w2 = \mathtt{[0,0,0,2147483645]}\]
% Lastly, we add $w3$ and $w0$, and so we get:
% \[ w0 + w2 =  \mathtt{[0,0,0,2147483645]} + \mathtt{[0,0,0,2147483645]} = \mathtt{[0,0,0,4294967290]}\]
% Now that we have the result of \texttt{step}, we shift it by $-1$:
% \[w = \mathtt{shift}_{-1} \mathtt{[0,0,0,4294967290]} = \mathtt{[0,0,4294967290]}\]
% Then we update the number of digits taken into account in the approximation by:
% \[l = l + n - 1 = 1 + 1 - 1 = 1\]

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
