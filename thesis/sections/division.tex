\section{Division}
\label{sec:div}

The last of the basic arithmetics is division. It is far more complicated than
the others and is intrinsically in conflict with our domain. We say the division
is \textit{exact} when the divisor precisely divides the dividend. When the
division is not exact, the result is ordinarily represented by a fraction -- yet
we do not desire to leave the domain of integers. Instead, we use the notion of
\textit{quotient} and \textit{remainder} commonly present in integer semantics:
\begin{align}
  u~\mathtt{quo}~v &\coloneq \lfloor u/v \rfloor\\
  u~ \mathtt{rem}~v &\coloneq u - \left( u~\mathtt{quo}~v \right)\cdot v
\end{align}
Usually, the quotient is associated with the division operator and the remainder
with the modulus operator. Our division computes both values and return them as
a pair.

A common way to reason about division is to multiply the dividend with the
inverse of the divisor, also called the reciprocal. GMP use reciprocals for
division by single precision, but since reciprocals are expensive to compute,
their basecase division use Knuth's algorithm for long division, also known as
\textit{grade-school} division \cite{GMP, knuth97}. This algorithm is inherently
sequential and each iteration only find one digit of the result, yielding poor
performance on GPGPU. As a result, we focus on algorithms based on the inverse
of the divisor.

A well known algorithm to find reciprocals is the Newton-Raphson method. It
takes an initial approximation, and through a series of iterative steps (also
called Newton iterations), refines the precision of the approximation. While it
too performs a number of inherently sequential iterations, the precision of the
approximation roughly doubles at each iteration, making it more suitable for
GPGPU than long division.

However, it presents a new hurdle w.r.t.\ the internal representation of both
the inverse and the intermediate approximations in iteration steps. One solution
is to use fractions internally and convert back to integers before returning the
output. The downsides to this solution is the potential loss of precision when
using floating points (i.e.\ it will no longer be an exact arithmetic) and the
GPU memory overhead of converting between representations.

Instead, we use Watt's efficient and exact arithmetic algorithm for computing
quotients, published in \cite{watt2023efficient}. The prerequisite of the
algorithm is the existence of a shift operation for the chosen data type -- which
is a very efficient operation for integers -- and the intuition is to utilize the
shift operation in order to avoid the domain change associated with computing
the inverse, instead computing what is refered to as the \textit{whole-shifted
  inverse}.

This section is structured as follows: In \ref{subsec:divalg} we give a detailed
introduction to the algorithm formulated by Watt in \cite{watt2023efficient}. We
also present some revisions to the algorithm -- notably an unconsidered corner
case -- and reflect on its adaptability to the domain of big integers. In
\ref{subsec:divproto} we show a sequential prototype of the algorithm written in
C. It serves to fully understand the complexities involved in adapting the
algorithm to big integers. Lastly, in \ref{subsec:divfut} we demonstrate how to
parallelize the algorithm using Futhark, based on the methods we discovered
during the prototyping.

\subsection{Algorithm}
\label{subsec:divalg}
{\red [TODO]}

We use the notation that $m$
remains the \textit{size} of the integer (array) while the \textit{precision}
refers to how many digits of the integer is used. E.g. the integer
$\bigint{2, 4, 0, 0}_{10}$ has size $4$ and precision $2$.

\subsection{Prototype}
\label{subsec:divproto}
{\red [TODO]}

We started by writing a prototype of the algorithm in C to better understand the
inner workings of the algorithm. In its creation, we discovered some
optimization with respect to our big integer data structure. Here are some
notable subroutines and how we handle them.

\begin{itemize}[leftmargin=*]
\item \textbf{Base Powers}\\
  These are prominent throughout the algorithm, and comes in a multitude of
  usecases. However, most of the time they express something structural about a
  big integer, and hence, can be optimized to a constant work check on the
  integer.

  E.g. consider the comparison $v > B^h$ for a big integer $v$ of precision $m$
  in base $B$. Instead of constructing $B^h$ and compare it to $v$, we can
  simply check whether any digits are index greater than $h$ are non-zero, the
  digit exactly at index $h$ is greater than $1$, or simply shortcircuit if
  $m < d$.
\item \textbf{Multmod}\\
  For big integers $u$ and $v$ in base $B$, we define
  $\fun{MultMod}(u,v,d) = (u \cdot v) \% (B^d)$. At first glance, this function
  requires to double the precision $m$ for the multiplication, and then run a
  computationally heavy modulus operation. However, taking the modulus of $B^d$
  corresponds to zeroing out the $m \log B - d$ upper bits of an integer.

  Thus, as these bits will not contribute to the result, $\fun{MultMod}$ is
  equivalent to a truncated multiplication. I.e. exact precision multiplication
  of precision $\fun{min}(d, m)$.

\item \textbf{Initial Approximation}\\
  The initial approximation is 4 digits divided by 2 digits and can be computed
  efficiently using register arithmetics, if we have access to registers of
  4$\times$ base size.

\item \textbf{PowDiff}\\
  This function computes the power difference of two big integers, their base
  and an exponent, defined $\fun{PowDiff}(u, v, h) = B^h - u \cdot v$. This function
  requires sign extension. However, instead of modifying our domain to signed
  big integers, we can simply return a boolean sign indicator - the sign will
  only dictate whether we add or subtract in the $\fun{Step}$-function, but the
  result will be unsigned regardless.

\item \textbf{Approximation Factor}\\
  Since the algorithm approximates the exact result by a factor of 1, i.e.
  $\delta = \{0,1\}$. We were not able to predict $\delta$, but it is trivially decidable
  by reversing the division with multiplication. This requires one extra
  multiplication, but is essentially free if we consider the remainder to be
  part of the algorithms output.
\end{itemize}

% \subsection{Single Precision Divisor}
% % In the prototype, a standard Long Division algorithm is used. Another way to
% % express the computation of long division is:
% % \begin{equation}
% %   \label{eq:1}
% %   q_i = \dfrac{\sum_{j=i}^{m-1} u_j \cdot B^{j-i}}{v}\% B
% % \end{equation}
% % E.g. consider the decimal number 500 divided by 4: We have
% % $q_0 = (500 / 4) \% 10 = 5$, $q_1 = (50 / 4) \% 10 = 2$ and
% % $q_2 = (5 / 4) \% 10 = 1$, i.e., the number 125.

% % We have the following rule for division and modulus:
% % \begin{equation}
% % \label{eq:2}
% % \frac{a}{b} \% c = () \% c
% % \end{equation}
% % \begin{equation}
% %   \label{eq:1}
% %   q_i = \dfrac{\sum_{j=i}^{m-1} \left( (u_j \% v)\cdot B^{j-i}\right) }{v}\% B
% % \end{equation}
% % \begin{equation}
% %   \label{eq:1}
% %   r_i = \left( \sum_{j=i}^{m-1} u_j \cdot B^{j-i} \right) \% v
% % \end{equation}

% % ~

% The quotient of size $m$ big integer $u$ and digit $d$ in base $B$ can be
% computed as:
% \begin{equation}
%   \label{eq:1}
%   q_i = \dfrac{\sum_{j=i}^{m-1} u_j \cdot B^{j-i}}{d}\% B
% \end{equation}
% E.g. consider the decimal number 500 divided by 4: We have
% $q_0 = (500 / 4) \% 10 = 5$, $q_1 = (50 / 4) \% 10 = 2$ and
% $q_2 = (5 / 4) \% 10 = 1$, i.e., the number 125. This approach does not fit a
% wordsize, as it includes the big integer $u$.

% In the sequential prototype, a standard Long Division algorithm is
% used\footnote{Since the divisor is single precision, it is called Short Division
%   instead of Long Division.}. The algorithm computes the partial quotient
% $q_{i\in\{0,..,m-1\}}$, using the partial remainder $r_{i\in\{0,..,m\}}$ as follows:
% \begin{equation}
%   \label{eq:1}
%   q_i = \left( r_{i+1} \cdot B + u_i\right) / d
% \end{equation}
% \begin{equation}
%   \label{eq:1}
%   r_i = \begin{cases} \left( r_{i+1} \cdot B + u_i\right) \% d & \text{if}~i<m \\ 0 & \text{otherwise} \end{cases}
% \end{equation}
% The intermideate results fits in a double word, and the algorithm is inherently
% sequential from left-to-right.

% From the definition of modulo, $a \% b = a - \lfloor \frac{a}{c} \rfloor \cdot b$,

\subsection{Futhark Implementation}
\label{subsec:divfut}

{\red [Missing]}




% As an example, lets handrun divison $\frac{u}{v}$ on the big integers $u = \texttt{[8,0,0,5]}$ and $v = \texttt{[4,2,0,0]}$ in base $B=2^{32}$. First, we must find $h$ such that $u\leq B^h$. A trivial pick is the precision of $u$ since the most significant digit is non-zero, i.e., $h=4$. Now comes the tricky part; we must find the whole shifted inverse of $v$ with respect to $h$, i.e., $\mathtt{shinv}_hv$.

% First we must find $k$ such that $B^k\leq v < B^{k+1}$. This is simply the precision - 1, so we have $k = 1$. Next we have the four special cases which guarantee that $B < v \leq \frac{B^h}{2}$. The first case is if $v < B$, or, if only the first digit of $v$ is set. The second case is if $v > B^h$, which means that $v>u$ and the division $\frac{u}{v}$ floors to $0$. The third case is if $2v > B^h$, which means that the division floors to $1$. The last case is if $v = B^k$, which means that $v$ is exactly a multiple of the base, and so the whole shifted inverse of $v$ is also a multiple of the base.

% In our example, we hit none of these special cases. Thus, we continue to compute a initial approximation of the whole shifted inverse. This approximation is computed by a division of a 4-digit big integer by a 2-digit big integer. Since we use base $B = 2^{32}$, we could do this in as one division in base $2^{128}$. However we chose to implement it, we get:
% \[l = \mathtt{min}(k,2) = \mathtt{min}(1,2) = 1\]
% \[V = \sum_{i=0}^lv_{k-l+i}B^i = 4 * B^0 + 2 * B^{1} = 8589934596\]
% \[w = (B^{2l}- V ) / (V + 1) = 18446744065119617020 / 8589934597 = 2147483645\]
% Hence, the initial approximation is the big integer $w = \mathtt{[2147483645,0,0,0]}$.

% We then check if this approximation is sufficient by the condition $h-k \leq l$, or in our case, $3 \leq 1$, which is clearly false. Since it is not a sufficient, we start refining. Let us consider \texttt{refine3} as the refine method, since this is the best proposed method.

% In this method, we have 2 guard digits, i.e:
% \[g = 2\]
% \[w = \mathtt{shift}_2w = \mathtt{[0,0,2147483645,0]}\]
% We then start the iterative refinement. This lasts until the sufficiency-condition above becomes true. We can see $l$ as the number of digits that are correctly approximated and $h - k$ as the total number of digits to approximate. In each iteration, we first find how much to grow $w$ denoted $n$ and how to scale $w$ in the iteration denoted $s$. In our case, we have:
% \[n = \mathtt{min}(h-k+1, l) = \mathtt{min}(2, 1) = 1\]
% \[s = \mathtt{max}(0, k - 2l + 1 - g) = \mathtt{max}(0,-2) = 0\]
% Now comes the meat of the iterations; we take a refinement \texttt{step}:
% \[ \mathtt{step}(k + l + n - s + g, \mathtt{shift}_{-s}v, w, n, l, g) = \mathtt{step}(3, 0, w, n, l, g)\]
% First we shift $w$ by the growth factor:
% \[w0 = \mathtt{shift}_nw = \mathtt{shift}_1 \mathtt{[0,0,2147483645,0]}= \mathtt{[0,0,0,2147483645]}\]

% Next up we compute the \texttt{powdiff} of $w$.
% \[w1 = \mathtt{powdiff}(v,w,h-n,l-g) = \mathtt{powdiff}(0,w,2,-1)\]
% This function computes $B^{h}-v\cdot w = B^{2}-0\cdot w = B^2$, but let us see how. First we find the difference between the number of approximated digits minus the guard digits and the precision after the multiplication plus 1:
% \[ L = \mathtt{prec}~v + \mathtt{prec}~w - l + 1 = 0 + 2 + 1 + 1 = 4\]
% Then, we check whether we can easily compute this, which we can if $w = 0 \lor v = 0 \lor L \geq h$, which is the case right now since $v = 0$ and also $L = 4 \geq 2 = h$. Hence, we return $B^{h}=B^{2}=18446744073709551616$.

% Now when we have the \texttt{powdiff}, we get our $w1$, which we then multiply by $w$:
% \[w1 = \mathtt{powdiff}(v,w,h-n,l-g) = 18446744073709551616\]
% \[w2 = w \times w1 = 730750817644604358339027025968017687532661637120\]
% As a big integer, we get $w2 = \mathtt{[0,0,0,0,2147483645]}$, which we now shift by $2n - h$:
% \[w3 = \mathtt{shift}_{2n - h}w2 = \mathtt{shift}_{2 - 3}w2 = \mathtt{shift}_{-1}w2 = \mathtt{[0,0,0,2147483645]}\]
% Lastly, we add $w3$ and $w0$, and so we get:
% \[ w0 + w2 =  \mathtt{[0,0,0,2147483645]} + \mathtt{[0,0,0,2147483645]} = \mathtt{[0,0,0,4294967290]}\]
% Now that we have the result of \texttt{step}, we shift it by $-1$:
% \[w = \mathtt{shift}_{-1} \mathtt{[0,0,0,4294967290]} = \mathtt{[0,0,4294967290]}\]
% Then we update the number of digits taken into account in the approximation by:
% \[l = l + n - 1 = 1 + 1 - 1 = 1\]

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
