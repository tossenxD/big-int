\section{Division}
\label{sec:div}

The last of the basic arithmetics is division. It is far more complicated than
the others and intrinsically in conflict with our domain. We say the division is
\textit{exact} when the divisor precisely divides the dividend. When the
division is not exact, the result is ordinarily represented by a fraction -- yet
we do not desire to leave the domain of integers. Instead, we use the notion of
\textit{quotient} and \textit{remainder} commonly present in integer semantics:
\begin{align}
  u~\mathtt{quo}~v &\coloneq \lfloor u/v \rfloor\\
  u~ \mathtt{rem}~v &\coloneq u - \left( u~\mathtt{quo}~v \right)\cdot v
\end{align}
Usually, the quotient is associated with the division operator and the remainder
with the modulus operator. Our division computes both values and return them as
a pair.

A common way to reason about division is to multiply the dividend with the
inverse of the divisor, also called the reciprocal. GMP use reciprocals for
division by single precision, but since reciprocals are expensive to compute,
their base case division use Knuth's algorithm for long division, also known as
\textit{grade-school} division \cite{GMP, knuth97}. This algorithm is inherently
sequential: It iteratively produce the result by finding one correct digit per
iteration, and thus, unfit for GPGPU. As a result, we focus on algorithms using
the inverse of the divisor.

A well known algorithm to find reciprocals is the Newton-Raphson method. It
takes an initial approximation, and through a series of iterative steps (also
called Newton iterations), refines the precision of the approximation. While it
too performs a number of inherently sequential iterations, the precision of the
approximation roughly doubles at each iteration, making it more suitable for
GPGPU than long division.

However, it presents a new hurdle w.r.t.\ the internal representation of both
the inverse and the intermediate approximations in iteration steps. One solution
is to use fractions internally and convert back to integers before returning the
output. The downsides to this solution is the potential loss of precision when
using floating points (i.e.\ it will no longer be an exact arithmetic) and the
overhead of converting between representations.

Instead, we use Watt's efficient and exact arithmetic algorithm for computing
quotients, presented in \cite{watt2023efficient}. The prerequisite of the
algorithm is the existence of a shift operation for the chosen data type -- which
is a efficient operation for integers -- and a multiplication method given as a
argument. The intuition is to utilize the shift operation in order to avoid the
domain change associated with computing the inverse, by instead computing what
is referred to as the \textit{whole shifted inverse}.

This section is structured as follows: In \ref{subsec:divalg} we give a detailed
introduction to the algorithm formulated by Watt in \cite{watt2023efficient}. We
also present a revision to the algorithm regading an unconsidered corner case,
and specialize it to the domain of big integers. In \ref{subsec:divproto} we
further discuss its adaptability w.r.t.\ big integers, and raise concerns and
solutions based on a sequential prototype of the algorithm written in C. It
serves to fully understand the complexities involved in adapting the algorithm
to big integers. Lastly, in \ref{subsec:divfut} we give an overview on how to
parallelize the algorithm based on Futhark.

\subsection{Algorithm}
\label{subsec:divalg}

Before discussing the exact division algorithm, we introduce a new notation: The
\textit{precision} of a big integer (denoted by $p$) refers to the number of
digits without leading zeroes. E.g.\ the integer $\arr{1,2,0}$ has size $m=3$
and precision $p=2$.

We will now give the intuition behind the algorithm defined by Watt in his paper
\cite{watt2023efficient}, and refer to his paper for the proofs and the generic
version. The foundation of the algorithm is a whole shift operator and a whole
shifted inverse operator:

\begin{definition}[whole shift and whole shifted inverse of big integers]
  We define a $n \in \mathbb{Z}$ whole shift and $n' \in \mathbb{N}$ whole shifted inverse of big
  integers $u\in \mathbb{N}$ and $v\in \mathbb{N}^{+}$ in base $B$ as:
  \begin{equation}\label{eq:shifts}
    \mathtt{shift}_n~u \coloneq \lfloor u \cdot B^n \rfloor \quad \qquad \mathtt{shinv}_{n'}~v \coloneq \lfloor B^{n'}/ v \rfloor
    \end{equation}
\end{definition}

A shift in our array-oriented representation behaves similarly to a binary
system arithmetic shift, e.g.\ $\mathtt{shift}_1~\arr{1,2,3} = \arr{0,1,2}$ and
$\mathtt{shift}_{-1}~\arr{1,2,3} = \arr{2,3,0}$. The shifted inverse has a more
abstract interpretation -- given some $n'>p$ it essentially behaves as a
fractional inverse that is then "shifted into our domain". Consider the
following example:

\begin{example}
Suppose we have the integer $u=\arr{1,2,3}$ in base $B=2^{32}$ and wish to divide
it by the integer $v=\arr{1,1,0}$ in base $B$. Since $v$ is of precision $p=2$,
we get a proper inverse representation of $v$ by computing the $n$ shifted
inverse for some $n>p$. We pick $n=3$:
\begin{equation}
\label{eq:3}
\mathtt{shinv}_3~\arr{1,1,0} = \arr{0,4294967295,0}
\end{equation}
We can then multiply $u$ with the shifted inverse (expanding the result size),
and gets:
\begin{equation}
  \label{eq:4}
  \arr{1,2,3}\cdot\arr{0,4294967295,0} = \arr{0,4294967295,4294967294,4294967294,2}
\end{equation}
Now, since the fractional part of the inverse was "shifted into our domain" by
3, the result of this multiplication is also shifted by 3 (from associativity of
multiplication). Hence we shift it by $-3$ (and compress it to the original
size):
\begin{equation}
  \label{eq:5}
  \mathtt{shift}_{-3}~\arr{0,4294967295,4294967294,4294967294,2} = \arr{4294967294,2,0}
\end{equation}
The correct answer is $\arr{4294967295,2,0}$, so the method is off by $1$. This
is an accommodated byproduct of computing the whole shifted inverse. However,
the method approximates the result by an difference of at most $1$, allowing us
to mechanically adjust the result.\newline
\end{example}

The formal definition given by Watt in Theorem 1 of his paper
\cite{watt2023efficient} is as follows:

\begin{definition}[quotient of big integers by whole shifted inverse]\label{def:quo}
  For the base $B$ big integers $u$ and $v$ and some $h\in \mathbb{N}$ s.t.\
  $u \leq B^h$, the quotient of $u$ by $v$ is:
  \begin{equation}
    \label{eq:defquo}
    u~\mathtt{quo}~v = \mathtt{shift}_{-h}~ (u \cdot \mathtt{shinv}_h~v) + \delta,\quad \text{where~} \delta \in \{0,1\}
  \end{equation}
\end{definition}

The challenge now lies in computing \texttt{shinv}. Watt's algorithm use a
Newton iteration over integers and specialized to the base in order to use
shifts rather than fractions. The algorithm can roughly be divided into three
steps:
\begin{enumerate}[label=\Roman*]
\item Handle the special (and easy) cases, namely when $v \leq B$ or $v > B^h/2$.\label{shinvI}
\item Find an initial approximation that guarantees the Newton iterations
  converges fast.\label{shinvII}
\item Refine the initial approximation iteratively until it is sufficient.\label{shinvIII}
\end{enumerate}
Listing \ref{shinv} below shows the pseudocode for this operation. In step
\ref{shinvI} we have four special cases. They serves dual purposes: To guarantee
that $B < v \leq B^h/2$ (an assumption of the initial approximation for fast
convergence) and to be faster. The first case is when $v$ only consists of a
single digit, and we use a division by single precision method.\footnote{As
  mentioned earlier in how GMP handle division, this case can generally be
  handled more efficient.} The next two cases is if $v > u$ or $2v > u$ and so
the inverse is $0$ and $1$, respectively. The last case is when $v$ is exactly a
power of its base, and we can use the rule $x^a/x^b=x^{a-b}$ instead.

Step \ref{shinvII} computes the initial approximation using the last three
digits of $v$, e.g.\ for $v$ of size $m$ we get $V= \arr{v[m-3],v[m-2],v[m-1]}$.
However, this is where we introduce our revision: Computing $V$ in this manner
requires $v \geq B^2$, which is not guaranteed by the special cases. This function
instead assumes that the precision of $v$ is not 2, i.e.
$B^k\leq v < B^{k+1} \land k \neq 1$. We show how to enforce this assumption when
presenting Listing \ref{div}, and shortly see why the assumption is important.

Hence, the initial approximation of $w$ (line 9) always consists of two leading
correct digits. Step \ref{shinvIII} checks whether the shifted inverse consists
of one or two digits, and return the approximation accordingly. If it needs more
digits of precision, it starts the refinement process using the specialized
Newton iteration. Watt presents three refinement methods with a varying degree
of optimizations. The method we use is the optimal (\texttt{refine3} of
Algorithm 1 in \cite{watt2023efficient}), which we describe shortly when
presenting Listing \ref{refine}. However, it use something called
\textit{shorter iterates} which has the side effect of each iteration being one
digit short of doubling the precision. This means that the number of correct
leading digits, from now on referred to as $l$, must be $\geq 2$. Thus, we if
$k = 1$ and we are in the case where $h-k>2$, then we would start refining on
$l=1$, and so one digit short of doubling $l=1$ is $l=1$, and hence, the
refinement never increases the precision and runs forever.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing \texttt{shinv}$_h~v$ in base $B$, where $B^k \leq v < B^{k+1}, k\neq 1$, \texttt{quo}$_{\mathtt{digit}}$ and \texttt{*}$_{\mathtt{digit}}$ are quotient and multiplication by single precision, and \texttt{REFINE} is an approximation refinement method.},label={shinv}]
fun SHINV h k v =
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvI}}! Special cases
  if v          <  B!$^{\phantom{\texttt{h}}}$! then return B!$^\mathtt{h}$! quo!$_{\texttt{digit}}$! v[0]
  if v          >  B!$^\texttt{h}$! then return 0
  if (v *!$_{\texttt{digit}}$! 2) >  B!$^\texttt{h}$! then return 1
  if v          == B!$^\mathtt{k}$! then return B!$^{\texttt{h}-\texttt{k}}$!
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvII}}! Initial approximation
  V = v[k-2] + (v[k-1] * B) + (v[k] * B!$^{\texttt{2}}$!)
  w = (B!$^{\texttt{4}}$! - V) / V + 1
  -- !{\hypersetup{allcolors=ForestGreen}\ref{shinvIII}}! Refine until sufficient
  if h - k <= 2 then return shift (h - k - 2) w 
  return REFINE v w h k 2
\end{lstlisting}

We will now present how to compute Definition \ref{def:quo} using \texttt{SHINV}
and how to enforce the assumption $k\neq 1$ using shifts. The Pseudocode is in
Listing \ref{div} and contains four steps. Step 1.\ (lines 3-4) computes the
assumptions straightforward using helpers from Figure \ref{divhelpers}. Step
2.\ handles the case $k=1$ by shifting both $u$ and $v$ by one. Note, a $n$-shift
is equivalent to multiplying by $B^n$, so the quotient is
unaffected. Furthermore, the relation between $h$ and $k$ remains the same, so
we do not introduce further iterations inside \texttt{SHINV}. Step 3.\ computes
the quotient and remainder from Equation (\ref{eq:defquo}) straightforward with
$\delta=0$, using some multiplication method \texttt{MUL} and absolute subtraction
method \texttt{SUB}$_{\mathtt{abs}}$. Lastly, step 4.\ finds $\delta$ and adjusts the
result accordingly, by checking whether the remainder is nonsensical.

\begin{figure}
{
\hrule\vspace*{-0.4ex}
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=pseudo,frame=,escapeinside={!}{!}]
-- finds `k` s.t. !$\green \texttt{B}^{\texttt{k}} \leq \texttt{v} < \texttt{B}^{\texttt{k}+\texttt{1}}$!
fun FINDK v =
  k = (sizeof v) - 1
  while v[k] == 0 do
    k -= 1
  return k

-- finds `p` s.t. !$\green \texttt{v} < \texttt{B}^{\texttt{p}}$!
fun PREC v =
  return FUNDK v + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[language=pseudo,firstnumber=11,frame=,escapeinside={!}{!}]
-- finds `h` s.t. !$\green \texttt{u} \leq \texttt{B}^{\texttt{h}}$!
fun FINDH u =
  h = FINDK u
  if u[h] == 1
  then return u
  else return u + 1

-- computes !$\green ( \texttt{v}\cdot \texttt{w})~\texttt{rem}~\texttt{B}^{\texttt{L}}$!
fun MULMOD v w L =
  return take L (MUL v w)
\end{lstlisting}
\end{minipage}\vspace*{-0.8ex}
\hrule
}
\caption{\footnotesize Helpers for Watt's division algorithm, where MUL is some given multiplication method.}
\label{divhelpers}
\end{figure}

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing $u~\mathtt{quo}~v$ and $u~ \mathtt{rem}~ v$ using Definition \ref{def:quo}, where \texttt{MUL} is some big int multiplication method, \texttt{SUB} subtraction method, \texttt{ADD} addition method, and with helpers from Listing \ref{divhelpers}.},label={div}]
fun DIV u v =
  -- 1. Find assumptions
  h = FINDH u
  k = FINDK v
  -- 2. Avoid non-terminating loop
  if k == 1 then u = shift 1 u
                 v = shift 1 v
                 h += 1
                 k += 1
  -- 3. Find quotient and remainder
  q = shift (-h) (MUL u (SHINV h k v))
  r = SUB!$_{\texttt{abs}}$! u (MUL q v)
  -- 4. Adjust for !\green$\delta$!
  if (r >= v) then q = ADD q 1
                   r = SUB r v
  return (q, r)
\end{lstlisting}

Next, we present the refinement method used by \texttt{SHINV}. The pseudocode is
in Listing \ref{refine} and contains no alterations to the original formulation
in \cite{watt2023efficient}. It use the method \texttt{STEP} to compute a Newton
iteration, which we shortly discuss when presenting Listing \ref{step}. This
method expands the specialized Newton iteration with two concepts;
\textit{shorter iterates} and \textit{divisor prefixes}. Shorter iterates is the
idea that not all digits of the intermediate results between iterations
matters. Since the precision roughly doubles, only the leading $l$ digits of the
intermediate results contributes to the refinement at each iteration. Line 5
computes the number of leading digits relevant for the current iteration. It
effectively allows us to truncate the size of of the big integers in the
\texttt{STEP} function, rather than doing each step in full size, s.t.\ the size
of the integers in each Newton step roughly doubles at each iteration.

In turn, this introduces the need for \textit{guard digits} because the
truncated sized steps may differ from the full sized steps, but only in the two
least significant digits. Hence, we use $2$ guard digits as defined in line 2,
and shift the approximate $w$ accordingly.

Lastly, the divisor prefixes is the idea that when the divisor $v$ is large
relative to shifted inverse approximated at each iteration, some of the leading
digits of $v$ does not contribute to the result of the iteration step. Instead,
we use a prefix of $v$ to further truncate the size of the big integers at each
step. This process too is imprecise, but it is defined such that it is accounted
for by the 2 guard digits. The scaling of $v$ is determined in line 6.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for refining the shifted inverse approximation $w$ of $l$ correct leading digits using the Newton iterate step function \texttt{STEP} of Listing \ref{step}, where the computational work of finding iterates is reduced by using shorter iterates and divisor prefixes.},label={refine}]
fun REFINE v w h k l =
  g = 2          -- guard digits to account for shorter
  w = shift g w  -- iterate and divisor prefix inexactness
  while h - k > l do
    n = min l (h - k + 1 - l)   -- `n` is amount to grow the iterate
    s = max 0 (k - 2*l + 1 - g) -- `s` is amount to scale `v` with
    w = shift (-1) (STEP (k + l + n - s + g) (shift (-s) v) w n l g)
    l += n - 1                  -- `l` is amount of correct leading digits
  return shift (-g) w
\end{lstlisting}

Next up is the Newton step function \texttt{STEP}. Its pseudocode is in Listing
\ref{step}. This is where most of the computational work lies since it contains
two multiplications. The function computes
$\mathit{step}(h,v,w,n) = w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$ as
given by Watt in \cite{watt2023efficient}. From the calling procedure of
\texttt{STEP} in \texttt{REFINE}, we get that the function corresponds to
$w\cdot B^l + \lfloor w \cdot (B^{l} - B^{-k+s-g} \cdot \lfloor v\cdot B^{-s} \rfloor \cdot w)\rfloor$, which satisfies the
properties of divisor prefix and shorter iterates proofed by Watt. We have made
no alterations to the original function formulation, except for explicitly
handling the sign and magnitude of the \texttt{POWDIFF} function.

\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode for computing a Newton step of the refinement method in Listing \ref{refine} for big ints $v$ and $w$ defined as $\mathit{step}(h,v,w,n) = w\cdot B^n + \lfloor w \cdot (B^{h-n} - v \cdot w) \cdot B^{2n - h}\rfloor$. $h$ is the parameter and $n$ the number of more digits to correctly refine in this step. $l$ is the number of leading digits currently correct and $g$ is the amount of guard digits added by the refinement method -- which are both passed down to and enables optimizations in the function \texttt{POWDIFF} given in Listing \ref{powdiff} that computes $B^{h-n}-v\cdot w$. \texttt{MUL} is some big int multiplication method, \texttt{SUB}$_{\mathtt{abs}}$ is absolute subtraction for big ints, and \texttt{ADD} is addition for big ints.},label={step}]
fun STEP h v w n l g =
  -- 1. Compute !$\green \texttt{B}^{\texttt{h}- \texttt{n}}- \texttt{v} \cdot \texttt{w}$!
  (pwd, sign) = POWDIFF v w (h-n) (l-g)
  -- 2. Compute and return !$\green\texttt{w} \cdot \texttt{B}^{\texttt{n} - \texttt{h}}+ \lfloor \texttt{w} \cdot ( \texttt{B}^{\texttt{h}}- \texttt{v}\cdot \texttt{w})\cdot \texttt{B}^{\texttt{2n} - \texttt{h}}\rfloor$!
  if sign
  then return SUB!$_{\texttt{abs}}$! (shift n w) (shift (2*n - h) (MUL w pwd))
  else return ADD!$_{\phantom{\texttt{abs}}}$! (shift n w) (shift (2*n - h) (MUL w pwd))
\end{lstlisting}

Lastly is the function \texttt{POWDIFF}. The term $B^h-v \cdot w$ appears in each
iteration step. While it can be computed straightforward, Watt increases the
efficiency by using close products. The idea is that in cases where the product
$v\cdot w$ is close to $B^h$ by a factor of $|B^h- v\cdot w|\leq B^L, L < h$, only the
lower $L$ digits of the product $v \cdot w$ is needed. Hence, we can use a truncated
multiplication of size $L$ rather than the size of $v$ and $w$. Listing
\ref{powdiff} shows the pseudocode for this function:
\begin{lstlisting}[language=pseudo,escapeinside={!}{!},caption={\footnotesize Pseudocode computing $\mathit{powdiff(v,w,h)}=B^{h}- v \cdot w$ efficiently using close products and helpers from Listing \ref{divhelpers}, where $l$ is number of correct leading digits in $w$, \texttt{MUL} is a big int multiplication method, and \texttt{SUB} is signed big int subtraction, with \texttt{false} indicating unsigned and \texttt{true} signed.},label={powdiff}]
fun POWDIFF v w h l =
  L = (PREC v) + (PREC w) - l + 1
  -- Constant case where !$\green\texttt{v}\cdot \texttt{w} = \texttt{0}$!, so result is B!$^{\green\texttt{h}}$!
  if (v == 0) || (w == 0) then return (B!$^{\texttt{h}}$!, false)
  -- Worst case where the multiplication !$\green\texttt{v}\cdot \texttt{w}$! is in full size
  if L >= h               then return SUB B!$^{\texttt{h}}$! (MUL v w)
  -- Close product case where only the lower L digits of !$\green\texttt{v}\cdot \texttt{w}$! is needed
  P = MULMOD v w L
  if P      == 0 then return (P, false)
  if P[L-1] == 0 then return (P, true)
  return SUB B!$^{\texttt{L}}$! P
\end{lstlisting}

Thus, by using our defined \texttt{DIV}, the revised \texttt{SHINV}, and the big
integer specialized \texttt{REFINE}, \texttt{STEP}, \texttt{POWDIFF} and helper
functions, we achieve an exact division operator for big integers. It relies on
arithmetic operators for addition, subtraction, and multiplication of big
integers (such as \textit{badd}, \textit{bsub}, and \textit{convmul}), but is
independent from the implementation of said operators. Hence, it is possible to
e.g.\ use different operators for different input sizes. The asymptotics is
dominated by the choice of multiplication operator (given that the addition and
subtraction is efficiently implemented). The iterative refinement process takes
$\lceil \log (h-k) \rceil$ iterations, and each iteration step runs two
multiplications. Due to the structure and optimizations of the refinement
process, the work is $O(M(m))$, where $M(m)$ is the work of the chosen
multiplication operator and $m$ is the size of the input integers
\cite{watt2023efficient}.




\subsection{Reflections and Prototyping}
\label{subsec:divproto}

This section discuss some concerns and solutions about the presented
algorithm. We wrote a sequential low-level prototype of the algorithm in C to
better understand its adaptation of our big integer representation. In its
creation, we discovered multiple interresting subject matters -- some of which
are included in the pseudocode given in section \ref{subsec:divalg}, and some of
which we present now.

\paragraph{Initial Approximation}
The initial approximation is found in step II of Listing \ref{shinv}. It gathers
the three leading digits of $v$ in $V$ and then finds $B^4-V$, giving a four
digit result. It then divides those four digits by $V$, giving a one or two
digit result. Hence, the quadruple base type \texttt{qint\_t} is necessary to
efficiently compute the initial approximation with register arithmetics. This
restricts a CUDA implementation to base \texttt{uint32\_t} and Futhark to
\texttt{u16}. In C, this process corresponds to Listing \ref{initC}:
\begin{lstlisting}[language=CPP,caption={\footnotesize C form initial approximation of \texttt{SHINV} efficient in base \texttt{uint\_t} of \texttt{bits} and quad type \texttt{quint\_t}.},label={initC},escapeinside={!}{!}]
quint_t V = (quint_t) v[k-2];                        // V  = v[k-2]
V +=       ((quint_t) v[k-1]) << bits;               // V += v[k-1] !$\green\cdot$! B!$\green ^{\texttt{1}}$!
V +=       ((quint_t) v[k])   << (2*bits);           // V += v[k]   !$\green\cdot$! B!$\green ^{\texttt{2}}$!

quint_t r = (((quint_t) 0) - V) / V + ((quint_t) 1); // r = (B!$\green ^\texttt{4}$! - V) / V + 1

w[0] = (uint_t) r;                                   // w = r 
w[1] = (uint_t) (r >> bits);                         // (assuming w was 0)
\end{lstlisting}

\paragraph{Base Powers}
These are prominent throughout the algorithm, and comes in a multitude of
usecases. When multiplied, they take shape of a \texttt{shift} operation, as
already incoorporated into the pseudocode. In the \texttt{POWDIFF} function,
they are returned or otherwise used directly, and hence, require construction in
a new memory space.

Remaining is the special cases of step I in the \texttt{SHINV} function. The
base powers are operands to comparisons that express something structural about
the divisor $v$. Hence, they can be integrated in said comparisons, avoiding
their construction.  E.g.\ consider the second case $v > B^h$. This optimizes to
the check: $\exists i\in \mathbb{N}.~(h<i<m \land v[i] \neq 0) \lor (h = i<m \land v[i] > 1)$.

(On a similar note, the multiplication by single precision of the third special
case $2v > B^h$ should be treated as $v > B^h/2$ and integrated in the
comparison as well.)

\paragraph{Preallocating Memory}
Throughout this Thesis, we have considered arithmetics of big integers to preserve
the input shape on output. The efficiency of this algorithm require fine control
over the size of operands at each iteration, so we need to adjust input-output
sizes according the iteration number. Furthermore, it is ideal to
preallocate a memory region large enough to hold the biggest intermediate value
of the refinement, rather than periodically doubling the memory regions of the
operands. From the analysis in Watt's paper \cite{watt2023efficient}, the size
of the operands at iteration $i$ is at most $2^i$. Since we have
$\lceil \log (h-k) \rceil$ iterations, we get the maximum operand size
$2^{\lceil \log (h-k) \rceil}$.


\paragraph{Guard Digits}
In order to get our prototype to validate, we adjusted the amount of guard
digits in the refinement method from $2$ to $m$, with $m$ being the size of the
inputs. Currently, we are not aware whether it is related to the algorithm or an
error in the prototype.

\subsection{Parallelization and Futhark Implementation}
\label{subsec:divfut}

{\red [Missing]}

multiple instances per block


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
