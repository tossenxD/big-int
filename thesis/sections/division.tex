\section{Division}
\label{sec:div}
As an example, lets handrun divison $\frac{u}{v}$ on the big integers $u = \texttt{[8,0,0,5]}$ and $v = \texttt{[4,2,0,0]}$ in base $B=2^{32}$. First, we must find $h$ such that $u\leq B^h$. A trivial pick is the precision of $u$ since the most significant digit is non-zero, i.e., $h=4$. Now comes the tricky part; we must find the whole shifted inverse of $v$ with respect to $h$, i.e., $\mathtt{shinv}_hv$.

First we must find $k$ such that $B^k\leq v < B^{k+1}$. This is simply the precision - 1, so we have $k = 1$. Next we have the four special cases which guarantee that $B < v \leq \frac{B^h}{2}$. The first case is if $v < B$, or, if only the first digit of $v$ is set. The second case is if $v > B^h$, which means that $v>u$ and the division $\frac{u}{v}$ floors to $0$. The third case is if $2v > B^h$, which means that the division floors to $1$. The last case is if $v = B^k$, which means that $v$ is exactly a multiple of the base, and so the whole shifted inverse of $v$ is also a multiple of the base.

In our example, we hit none of these special cases. Thus, we continue to compute a initial approximation of the whole shifted inverse. This approximation is computed by a division of a 4-digit big integer by a 2-digit big integer. Since we use base $B = 2^{32}$, we could do this in as one division in base $2^{128}$. However we chose to implement it, we get:
\[l = \mathtt{min}(k,2) = \mathtt{min}(1,2) = 1\]
\[V = \sum_{i=0}^lv_{k-l+i}B^i = 4 * B^0 + 2 * B^{1} = 8589934596\]
\[w = (B^{2l}- V ) / (V + 1) = 18446744065119617020 / 8589934597 = 2147483645\]
Hence, the initial approximation is the big integer $w = \mathtt{[2147483645,0,0,0]}$.

We then check if this approximation is sufficient by the condition $h-k \leq l$, or in our case, $3 \leq 1$, which is clearly false. Since it is not a sufficient, we start refining. Let us consider \texttt{refine3} as the refine method, since this is the best proposed method.

In this method, we have 2 guard digits, i.e:
\[g = 2\]
\[w = \mathtt{shift}_2w = \mathtt{[0,0,2147483645,0]}\]
We then start the iterative refinement. This lasts until the sufficiency-condition above becomes true. We can see $l$ as the number of digits that are correctly approximated and $h - k$ as the total number of digits to approximate. In each iteration, we first find how much to grow $w$ denoted $n$ and how to scale $w$ in the iteration denoted $s$. In our case, we have:
\[n = \mathtt{min}(h-k+1, l) = \mathtt{min}(2, 1) = 1\]
\[s = \mathtt{max}(0, k - 2l + 1 - g) = \mathtt{max}(0,-2) = 0\]
Now comes the meat of the iterations; we take a refinement \texttt{step}:
\[ \mathtt{step}(k + l + n - s + g, \mathtt{shift}_{-s}v, w, n, l, g) = \mathtt{step}(3, 0, w, n, l, g)\]
First we shift $w$ by the growth factor:
\[w0 = \mathtt{shift}_nw = \mathtt{shift}_1 \mathtt{[0,0,2147483645,0]}= \mathtt{[0,0,0,2147483645]}\]

Next up we compute the \texttt{powdiff} of $w$.
\[w1 = \mathtt{powdiff}(v,w,h-n,l-g) = \mathtt{powdiff}(0,w,2,-1)\]
This function computes $B^{h}-v\cdot w = B^{2}-0\cdot w = B^2$, but let us see how. First we find the difference between the number of approximated digits minus the guard digits and the precision after the multiplication plus 1:
\[ L = \mathtt{prec}~v + \mathtt{prec}~w - l + 1 = 0 + 2 + 1 + 1 = 4\]
Then, we check whether we can easily compute this, which we can if $w = 0 \lor v = 0 \lor L \geq h$, which is the case right now since $v = 0$ and also $L = 4 \geq 2 = h$. Hence, we return $B^{h}=B^{2}=18446744073709551616$.

Now when we have the \texttt{powdiff}, we get our $w1$, which we then multiply by $w$:
\[w1 = \mathtt{powdiff}(v,w,h-n,l-g) = 18446744073709551616\]
\[w2 = w \times w1 = 730750817644604358339027025968017687532661637120\]
As a big integer, we get $w2 = \mathtt{[0,0,0,0,2147483645]}$, which we now shift by $2n - h$:
\[w3 = \mathtt{shift}_{2n - h}w2 = \mathtt{shift}_{2 - 3}w2 = \mathtt{shift}_{-1}w2 = \mathtt{[0,0,0,2147483645]}\]
Lastly, we add $w3$ and $w0$, and so we get:
\[ w0 + w2 =  \mathtt{[0,0,0,2147483645]} + \mathtt{[0,0,0,2147483645]} = \mathtt{[0,0,0,4294967290]}\]
Now that we have the result of \texttt{step}, we shift it by $-1$:
\[w = \mathtt{shift}_{-1} \mathtt{[0,0,0,4294967290]} = \mathtt{[0,0,4294967290]}\]
Then we update the number of digits taken into account in the approximation by:
\[l = l + n - 1 = 1 + 1 - 1 = 1\]


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../main"
%%% End:
